# Java基础语法
- 一个Java程序可以认为是一些列对象的集合，而这些对象通过调用彼此的方法来协同工作。
	- 对象：对象是类的一个实例，有状态和行为
	- 类：类是一个模板，他描述一类对象的行为和状态
	- 方法：方法就是行为，一个类可以有很多方法。逻辑运算，数据修改都是在方法中完成的
	- 实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。
- 编写Java时，应注意以下几点
	- 大小写敏感
	- 类名：大驼峰命名法
	- 方法名：小驼峰命名法
	- 原文件名：源文件名和类名相同（public修饰）
	- 主方法入口：public static void main(String[] args)
- Java标识符
	- Java所有组成部分都需要名字。类名，变量名，以及方法名都被称作标识符。
	- 关于Java标识符，有以下几点需要注意
		- 所有的标识符都应该以大小写字母，美元符，下划线开始
		- 首字符之后可以是字母，美元符，下划线或者数字的任何字符组合
		- 关键字不能用作标识符
		- 标识符是大小写闽敏感的
- Java修饰符
	- 向其他语言一样，Java可以使用修饰符来修饰类中的方法和属性
		- 访问控制修饰符：default,public,protected,private
		- 非访问控制修饰符：final,abstract,static,synchronized
- Java变量
	- 局部变量
	- 类变量（静态变量）
	- 成员变量（非静态变量）
- Java数组
	- 数组是存储在堆上的对象，可以保存多个同类型变量。
- Java枚举
	- 枚举限制变量只能取预先设定好的值。使用枚举可以减少代码中的bug

			class FreshJuice {
			   enum FreshJuiceSize{ SMALL, MEDIUM , LARGE }
			   FreshJuiceSize size;
			}
			 
			public class FreshJuiceTest {
			   public static void main(String []args){
			      FreshJuice juice = new FreshJuice();
			      juice.size = FreshJuice.FreshJuiceSize.MEDIUM  ;
			   }
			}

- 继承
	- 在Java中，一个类可以由其他类派生。如果要创建一个类，而且已经存在一个类具有你所需要的属性和方法，那么你可以将新创建的类继承该类。
	- 利用继承的方法，可以重用已存在的类的方法和属性，而不用重写这些代码。被继承的类称为超类，派生类称为子类
- 接口
	- 在Java中，接口可理解为对象间相互通信的协议。结构在继承中扮演者很重要的角色。
	- 接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类

# Java对象和类
- Java作为一种面向对象语言，支持以下基本概念
	- 多态
	- 继承
	- 封装
	- 抽象
	- 类
	- 对象
	- 实例
	- 方法
	- 重载
- Java中的类

		public class Dog{
		  String breed;
		  int age;
		  String color;
		  void barking(){
		  }
		 
		  void hungry(){
		  }
		 
		  void sleeping(){
		  }
		}
	- 一个类可以包含以下类型变量
		- 局部变量：在方法，构造方法或者语句块中定义的变量称为局部变量。变量声明和初始化都是在方法中，方法结束以后，变量就会自动销毁
		- 成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法，构造方法和特定的类的语句块访问
		- 类变量：类变量也生命在类中，方法体之外，但必须声明为static类型。
	- 一个类可以拥有多个方法
- 构造方法
	- 每个类都有构造方法。如果没有显示的定义构造方法，Java编译器将会为该类提供一个默认构造方法。
	- 再创在一个对象的时候，至少要调用一个构造方法，狗在方法的名称必须于类同名，一个类可以有多个构造方法。

			public class Puppy{
			    public Puppy(){
			    }
			 
			    public Puppy(String name){
			        // 这个构造器仅有一个参数：name
			    }

- 创建对象
	- 对象是根据类创建的，在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步
		- 声明：声明一个对象，包括对象名称和对象类型
		- 实例化：使用关键字new来创建一个对象
		- 初始化：使用new创建对象时，会调用构造方法来初始化对象

				public class Puppy{
				   public Puppy(String name){
				      //这个构造器仅有一个参数：name
				      System.out.println("小狗的名字是 : " + name ); 
				   }
				   public static void main(String[] args){
				      // 下面的语句将创建一个Puppy对象
				      Puppy myPuppy = new Puppy( "tommy" );
				   }
				}

- 访问实例变量和方法
	- 创建对象后，使用“.”点操作符可以访问对象的变量和方法

- 源文件声明规则
	- 当一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些
		- 一个源文件中只能有一个public类
		- 一个源文件中可以有多个public类
		- 源文件的名称应该和public类的名称保持一致
		- 如果一个类定义在某个包中，那么package语句应该在源文件中最前面
		- import语句和package语句对源文件中定义的所有类都有效，再同一源文件中，不能给不同的类不同的包声明。
	- Java中还有一些特殊的类，如内部类，匿名类。

- Java包
	- 报主要用来对类和接口进行分类，当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。

	- import语句
		- 在Java中如果给出一个完整的限定名，包括包名，类名，那么Java编译器就可以很容易的定位到源代码或者类。import语句就是用来提供一个合理的路径，使得编译器可以找到某个类
		- 下面的命令用来载入java_installation/java/io路径下的所有类
	
				import java.io.*;

# Java基本数据类型
	内置数据类型
	引用数据类型

- 内置数据类型
	- byte 1字节 有符号 二进制补码表示的整数 默认值为0
	- short 2字节 有符号 二进制补码表示的整数 默认值为0
	- int 4字节 有符号 二进制补码表示的整数 默认值为0
	- long 8字节 有符号 二进制补码表示的整数 默认值为0L
	- float 4字节 有符号 符合IEEE 754标准的浮点数（科学计数法输出） 默认值为0.0f
	- double 8字节 有符号 符合IEEE 754标准的浮点数（科学计数法输出） 默认值为0.0d
	- boolea 1位 只有两个取值 true和false 默认值为false
	- char 单一的16位Unicode字符 默认值为'u0000'
	- String 字符串 默认值为null

- 引用类型
	- 在Java中引用类型的变量非常类似于c和c++中的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。变量一旦声明后，类型就不能修改了
	- 对象，数组都是引用数据类型
	- 所有引用类型的默认值都时null
	- 一个引用变量可以用来引用任何与之兼容的类型
	- Site site = new Site("Runoob");
- Java常量
	- 常量在程序运行时不能被修改
	- 在Java中使用final关键字来修饰常量，声名方式和变量类似
	- 常用大写字母表示常量

			final double PI = 3.14
	- byte，short，int，long都可以用8进制和16进制表示 分别以0开头和0x开头
	- Java中字符串包含在双引号之间
	- 字符串常量和字符常量都可以包含任何unicode字符
- Java语言支持的一些特殊转义字符
	- \n 换行
	- \r 回车
	- \f 换页符
	- \b 退格
	- \0 空字符
	- \s 字符串
	- \t 制表符
	- \" 双引号
	- \\ 反斜杠
	- \ddd 八进制字符（ddd）
	- \uxxxx 十六进制Unicode字符（xxxx）
- 自动类型转换
	- 低--------------------------------------------->高
	- byte，short，char -> int -> long -> float -> double
	- 数据类型必须满足以下规则
		- 不能对boolean类型进行转换
		- 不能把对象类型转换成不相关类的对象
		- 在容量大的类型转换为容量小的类型时必须使用强制转换
		- 装欢过程中可能导致溢出或**损失**精度
		- 浮点数到整数的转换是舍弃小数而不是四舍五入
		- char类型转换成int类型按照ascii码转换

- 强制类型转换
	- 转换的数据类型必须是兼容的
	- 格式 (type)value type是要强制转换之后的数据类型。

- 隐含强制类型转换
	- 整数的默认类型是int
	- 浮点型不存在这种情况，因为在定义float类型时必须在数字后面跟上F或f


# Java变量类型
- 在Java语言中，所有的变量在使用前必须声明。
- Java语言支持的变量类型有
	- 类变量（静态变量）：独立于方法之外的变量，用static修饰
		- 类变量也称为静态变量，在类中以static关键字声明，但必须在方法之外
		- 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝
		- 静态变量除了被声明为常量外很少使用，常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变
		- 静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量
		- 静态变量在第一次被访问时候创建，在程序结束时候销毁
		- 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。
		- 默认值和实例变量相似。数值型变量的默认值为0，布尔值为false，引用类型为null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句中初始化
		- 静态变量可以通过ClassName.VariableName的方式访问
	- 实例变量：独立于方法之外的变量，没有static修饰
		- 实例变量声明在一个类中，但在方法，构造方法和语句块之外
		- 当一个对象被实例化之后，每个实例变量的值就跟着确定
		- 实例变量在对象创建的时候创建，在对象被销毁的时候销毁
		- 实例变量的值应该至少被一个方法，构造方法或语句块引用，使得外部能够通过这些方式获取实例变量信息；
		- 实例变量可以在声明在使用前或者使用后；
		- 访问修饰符可以修饰实例变量
		- 实例变量对于类中的方法，构造方法，或者语句块是可见的。一般情况下应该把实例变量设为私有，通过使用访问修饰符可以使实例变量对子类可见
		- 实例变量具有默认值。数值型变量的默认值使0，布尔型为false，引用类型变量为null。变量的值可以在声明时指定，也可以在构造方法中指定
		- 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名ObejectReference.VariableName。
	- 局部变量：类的方法中的变量
		- 局部变量声明在方法，构造方法，或者语句块中
		- 局部变量在方法，构造方法，语句块执行的时候创建，当他们执行完成后，变量将会被销毁
		- 访问修饰符不能用于局部变量
		- 局部变量只在声明他们的方法，构造方法，或语句块中可见
		- 局部变量是在栈上分配的
		- 局部变量没有默认值，所以在局部变量在声明后，必须经过初始化才可以使用


# Java修饰符
- 主要分为两类
	- 访问修饰符
	- 非访问修饰符

## 访问控制修饰符
	default(即缺省，什么也不写)：在同一包内可见，不适用任何修饰符。
		使用对象：类，接口，变量，方法
	private：在同一类内可见。
		使用对象：变量，方法。注意：不能修饰类（外部类）
	public：对所有类可见。
		使用对象：类，接口，变量，方法
	protected：对同一包内的类和所有子类可见。
		使用对象：变量，方法。 注意：不能修饰类（外部类）
- 默认访问修饰符-不使用任何关键字
	- 使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final。 而接口里的方法默认情况下访问权限为public
- 私有访问修饰符-private
	- 私有访问修饰符是最严格的访问级别，所以被声明为private的方法，变量和构造方法只能被所属类访问，并且类和接口不能声明为private。
	- 声明为私有访问类型的变量只能通过类中的公共的getter方法被外部访问
	- private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据
- 公有访问修饰符-public
	- 被声明为public的类，方法构造方法和接口能够被任何其他类访问。
	- 如果几个相互访问的public类分布在不同的包中，则需要导入相应public类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承
- 受保护的访问修饰符-protected
	- **子类与基类在同一包中：被声明为protected的变量，方法和构造器能被同一个包中的任何其他类访问**
	- **子类与基类不在同一包中：子类可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法**
	- protected可以修饰数据成员，构造方法，方法成员，**不能修饰类（内部类除外）**
	- 接口及结构的成员变量方法不能声明为protected。
- 访问控制和继承（方法继承规则）
	- 父类中声明为public的方法在子类中必须为public。
	- 父类中声明的protected方法在子类中要么声明为protected，要么声明为public，不能声明为private。
	- 父类中声明为private的方法不能够被继承。

## 非访问控制修饰符
	static修饰符，用来修饰类方法和变量
	final修饰符，用来修饰类，方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，不可被修改
	abstract修饰符，用来创建抽象类和抽象方法。
	synchronized和volatile修饰符，主要用于线程的变成

- static修饰符
	- 静态变量：
		- static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，他的静态变量只有一份拷贝。静态变量也称为类变量。局部变量不能被声明为static变量
	- 静态方法：
		- static关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据
		- 系统会为静态方法分配一个固定的内存空间。而普通方法会随着对象的调用而加载，当使用完毕，会自动释放掉空间。
		- 普通方法的好处是，动态回话了内存空间的使用，节省内存资源。
		- 静态方法方便，运行快，而如果全部方法都用静态方法，呢么每个方法都要有一个固定的内存空间，太占内存。
		- 这就解释了，为什么静态方法可以直接被类名调用，而不需要用对象调用，因为他有固定空间，随类的加载而加载。
		- 静态方法不需要对象，他在定义对象前就有了，因此可以方便地直接类名调用，不需要实例化对象。
	- 对类变量和方法的访问可以直接使用classname.variablename和classname.methodname的方式访问
- final修饰符
		
		final表示最后的，最终的含义，变量一旦复赋值后，不能被重新赋值。被final修饰的实例变量必须显式的指定初始值。
		final修饰符场合static修饰符一起使用来创建常量
	- final方法
		- 类中的final方法可以被子类继承，但是不能被子类修改。
		- 声明final方法的主要目的是防止该方法的内容被修改
	- final类
		- final类不能被继承，没有类能够继承final类的任何特性
- abstract
	- 抽象类：
		- 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充
		- 一个类不能同时被abstract和final修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。
		- 抽象类可以包含抽象方法和非抽象方法

	- 抽象方法
		- 抽象方法是一种么有任何实现的方法，该方法的具体实现由子类提供
		- 抽象方法不能被声明为final和static
		- 任何继承抽象类的子类必须实现父类的所有抽象方法，除非改子类也是抽象类
		- 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。
		- 抽象类可以不包含抽象方法。
		- 抽象方法的声明以分号结尾，例如 public abstract sample();
- synchronized修饰符
	- 此关键字修饰的方法同一时间只能被一个线程访问
- transient修饰符
	- 序列化的对象包含被transient修饰的实例变量时,Java虚拟机跳过该特定的变量
	- 该修饰符包含在定义变量的与剧中,用来预处理类和变量的数据类型
- volatile修饰符
	- 此修饰符修饰的成员变量在每次被线程访问时,都强制从共享内存中重新读取该成员变量的值.而且,党成员变量发生变化时,会强制线程将变化值协会到共享内存.这样在任何时刻,两个不同的线程总时看到某个成员变量的同一个值.
	- 一个volatile对象引用可能是null


# Java运算符
	Java中运算符分为以下几种:
		算术运算符
		关系运算符
		位运算符
		逻辑运算符
		赋值运算符
		其他运算符
- 算术运算符
	- + - * / 
	- 取余:%
	- 自增运算符:++ --
		- 分为前缀自增自减和后缀自增自减

- 关系运算符
	- == != < > <= >=

- 位运算符
	- 位运算符应用于整数类型,长整形,短整型,字符型,和字节型.
	- &:如果对应位都是1,则结果位1,否则为0
	- |:如果对应位都是0,则结果为0,否则为1
	- ^:如果对应位值相同,则结果位0,否则为1
	- ~:按位取反运算符,翻转操作数的每一位,即0变成1,1变成0
	- <<:按位左移运算符.左操作数按位左移右操作数的指定位数
	- >>:按位右移运算符.左操作数按位右移右操作数的指定位数

- 逻辑运算符
	- &&:逻辑与操作符.仅当两个操作数都为真,条件才为真
	- ||:逻辑或操作符.如果任何两个操作数任何一个为真,则条件为真
	- ! :逻辑非运算符.用来反转操作数的逻辑状态.如果条件为true,则结果为false
	- **逻辑运算符存在短路现象**:
		- 如果第一个操作执行后已经可以判断表达式结果,则第二个操作不会执行;

- 赋值运算符
	-  = += -= *= /= (%)= <<= >>= |= ^=

- 条件运算符
	- a?b:c
	- 若a为true, 则执行b, 否则执行c
- instanceof 运算符
	- 用于操作对象实例，检查该对象是否是一个特定类型（类类型或者接口类型）
	- 用法 obj instanceof obj 
	- 返回boolean类型


# Java循环结构
- while 
- do...while
- for

- **增强for循环**

		for(声明语句:表达式）{
			//代码
		}

	- 声明语句：声明新的局部变量，作用域为循环语句块，变量类型要与数组元素的类型匹配
	- 表达式：数组对象或者返回数组的方法。

- 关键字
	- break：跳出最里层的循环
	- continue：立刻进入下一次迭代

# 条件
- if else
- if  else if  else
- 嵌套


# switch case语句
- 支持变量类型：byte short char int String
- default ：在没有执行任何case语句的时候执行

# Java Math类
- java Math类包含了执行基本数学运算的属性和方法，如初等指数，对数，平方根和三角函数等
- Math的方法都被定义为static形式，通过Math类可以在主函数中直接调用

# JavaCharacter类
- Character类用于对单个字符进行操作
- Character类中包含了一个基本数据类型char
- 实际开发过程中，经常遇到需要使用对象，而不是内置数据类型的情况，Java为内置数据类型char提供了包装类Character

# Java String类
- String类是不可改变的，所以一旦创建了String对象，那么他的值就无法改变了
- 如果需要对字符串做很多修改，那么应该选择使用StringBuffer或Stringbuilder类
- 常用的接口
	- 返回长度:str.length（）
	- 连接字符串：str1.concat(str2)，更常用的是用“+"

# Java StringBuffer StringBuilder类
- 当对字符串进行修改的时候，需要使用Stringbuffer和StringBuilder类
- 和String不同的是，StringBuffer和StringBuilder类能够被多次的修改，并且不产生新的未使用对象。Stringbuilder在Java5中被提出，他和StringBuffer类不同的地方在于StringBuilder的方法不是线程安全的，但是StringBuilder具有速度优势


# Java数组
- Java语言中提供的数组是用来存储固定大小的同类型元素
- 声明方法：
	- dataType[] arrayRefVar;
	- 使用new创建：arraRefVar = new datatype[size]

# java 日期时间
- Java.util包提供了date类来封装当前的日期和时间。