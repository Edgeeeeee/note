# 关系数据理论
- 好的关系模式：
	- 不会发生插入异常，删除异常，更新异常
	- 数据冗余尽可能地少
### 规范化
- 改造关系模式，通过分解关系模式来消除其中不合适的数据依赖
####函数依赖
- 定义：设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称：X函数确定Y，或Y函数依赖于X，记作X -> Y。X称为这个函数依赖的决定属性集。
- 说明
	- 函数依赖不是指关系模式R的某个或某些盥洗室里满足的约束条件，而是指所有的关系实例均要满足的条件
	- 函数依赖是语义范畴的概念，只能根据语义来确定函数依赖
- 平凡函数依赖与非平凡函数依赖
	- 如果X -> Y，但Y不是X的子集，则称X -> Y是非平凡的函数依赖
	- 如果Y是X的子集，则为平凡的函数依赖
	- 任意关系模式，平凡函数依赖都是必然成立的，他不反应新的语义，因此若不特别声明，我们总是讨论非平凡的函数依赖
- 完全函数依赖和部分函数依赖
	- 在关系模式R(U)中，如果X->Y，并且对于X的任何一个真子集X都**没有**X'->Y，则称此依赖为完全函数依赖，否则为部分函数依赖
- 传递函数依赖
	- 在关系模式R(U)中，如果X决定Y，Y决定Z，且Y是X的子集，Y不决定X，则称Z传递依赖于X
	- 注意：如果X决定Y，Y决定X，则Z直接依赖于X
- 范式	
	- 范式是符合某一种级别的关系模式的集合
	- 关系数据库中的关系必须满足一定的要求。满足不同要求的为不同范式。
	- 1NF
		- 如果一个关系模式R的所有属性都是不可分的基本数据项，则R属于1NF
		- 第一范式是对关系模式的最起码的要求，不满足第一范式的数据库不能成为关系数据库
	- 2NF
		- 每一个非主属性完全函数依赖于码
		- 即消除非主属性对码的部份依赖
		- 插入异常、删除异常、数据冗余度大、修改复杂
	- 3NF
		- 关系模式R的每一个非主属性既不部份依赖于候选码，也不传递依赖于候选码
		- 一定程度上解决了2NF的问题
	- BCNF
		- 设关系模式R(U,F)属于第一范式，如果对于R的每个函数依赖X->Y,若Y不属于X，则X必含有候选码，那么R属于BCNF
		- 即R中的所有属性(包括主属性)都完全函数依赖于码
		- 性质
			- 所有非主属性都完全函数依赖于每个候选码
			- 所有主属性都完全函数依赖与每个不包含它的候选码
			- 没有任何属性完全啊函数依赖与非码的任何一组属性
	- 3NF 与 BCNF 的关系 
		- 如果关系模式R属于BCNF，则必定有R属于3NF
		- 如果R属于3NF，且R只有一个候选码，则R必属于BCNF
	- 多值依赖
		- 例如:学校中一门课程由多个教师讲授，他们使用相同的一套参考书
		- 一个课程决定多个老师，多个参考书
		- 多值依赖记作：X ->-> Y
		- 性质
			- 对称性：若X ->-> Y，则X ->-> Z,Z = U-X-Y
			- 传递性：若X ->-> Y，Y ->-> Z,则X ->-> Z-Y
			- 函数依赖是多值依赖的特殊情况
			- 若X→→Y，X→→Z，则X →→Y∪Z
			- 若X→→Y，X→→Z，则X→→Y∩Z
			- 若X→→Y，X→→Z，则X→→Y-Z , X→→Z-Y。
		- 多值依赖与函数依赖的区别
			- 若函数依赖X→Y在R（U）上成立，则对于任何Y'为Y的子集均有X→Y' 成立
			- 多值依赖X→→Y若在R(U)上成立，不能断言对于任何Y'为Y的子集有X→→Y' 成立
			- 数据冗余度大，插入复杂，删除复杂，修改复杂
	- 4NF
		- 对于R的每个非平凡多值依赖X ->-> Y，X都含有候选码，则R属于4NF
	- **规范化**
		- 一个低一级的范式，通过模式分解可以转换为若干个高一级范式的关系模式集合，这种过程就叫关系模式的规范化
		- 一个例子
		- [![EyxBXn.md.jpg](https://s2.ax1x.com/2019/05/08/EyxBXn.md.jpg)](https://imgchr.com/i/EyxBXn)

