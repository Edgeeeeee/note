# 运输层
### 运输层协议概述
##### 进程之间的通信
- 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，**它属于面向通信部分的最高层，同时也是用户功能中的最低层。**
- 当网络的边缘部分中的两个主机使用网络核心部分的功能进行端到端的通信时，**只有位于网络便于部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用下三层的功能。**
- 运输层的作用：**为相互通信的应用进程提供了逻辑通信**
	- ![VNRElj.png](https://s2.ax1x.com/2019/06/05/VNRElj.png)
	- **逻辑通信**的意思是好像是这样通信，但事实上并非真的这样通信
	- **从IP层上来说，通信的两端是两台主机**。但两台主机之间的通信这种说法还不够清楚。
	- 严格来讲，两台主机进行通信就是两台主机中的应用进程互相通信
	- **从运输层的角度看，通信的真正端点并不是主机而是主机中的进程**。也就是说，端到端的通信是应用进程之间的通信。
	- 运输层和网络层有明显的区别：
		- 网络层是为主机之间提供逻辑通信的，而运输层为应用进程之间提供端到端的逻辑通信
		- ![VNRgBt.png](https://s2.ax1x.com/2019/06/05/VNRgBt.png)
	- 在一台主机中经常有**多个应用进程**同时分别和另一台主机中的多个应用进程通信
	- 这表明运输层有一个很重要的功能——**复用**和**分用**
	- 根据应用程序的不同需求，运输层需要有两种不同的运输协议，即**面向连接的TCP和无连接的UDP**
	- ![VNRj4U.png](https://s2.ax1x.com/2019/06/05/VNRj4U.png)
- 屏蔽作用
	- 运输层向高层用户**屏蔽**了下面网络核心的细节（如网络拓扑，错采用的路由选择协议等），他使应用进程看见的就是好像在两个运输层实体之间**有一条端到端的逻辑通信**
	- ![VNWSgJ.png](https://s2.ax1x.com/2019/06/05/VNWSgJ.png)
- 两种不同的运输协议
	- 这条逻辑通信对信道上层的表现却因运输层使用的不同协议而又很大的差别。
	- 当运输层采用面向连对接的TCP协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就像**一条全双工的可靠信道**
	- 当运输层采用无连接的**UDP协议**时，这种逻辑通信信道是一条**不可靠信道**

##### 运输层的两个主要协议
- TCP/IP的运输层有两个主要协议
	- **用户数据报协议UDP**
	- **传输控制协议TCP**
	- ![VNWQbt.png](https://s2.ax1x.com/2019/06/05/VNWQbt.png)
- TCP与UDP
	- 两个对等运输实体在通信时传送的数据单位叫**做运输协议数据单元**TPDU
	- TCP传送的数据单位协议时**TCP报文段**
	- UDP传送的数据单位协议时**UDP报文**和**用户数据报**
	- UDP：一种无连接协议
		- **提供无连接服务**
		- **在传送数据之前不需要先建立连接**
		- 传送的数据单位协议时UDP报文和用户数据报
		- 对方的运输层在收到UDP报文后，不需要给出任何确认
		- **虽然UDP不提供可靠交付**，但在某些情况下UDP是一种最有效的工作方式
	- TCP：一种面向连接的协议
		- **提供面向连接的服务**
		- 传送的数据单协议时**TCP报文段**
		- **TCP不提供广播或多播服务**
		- 由于TCP**要提供可靠的，面向连接的运输服务**因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。
	- 还要强调两点
		- 运输层的UDP用户数据报与网际层IP数据报有很大区别
			- IP数据报要经过互联网许多路由器的存储和转发
			- UDP用户数据报是在运输层的端到端凑宪法的逻辑信道中传送的
		- TCP报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道经过了那些路由器，而且这些路由器也根本不知道上面的运输层是否建立了TCP连接。
##### 运输层的端口
- 运行在计算机中的进程使用**进程标识符**来标志的
- **但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进标识符。**这是应为在互联网上是哟弄个的计算机操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。
- 为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用**统一的方法对TPC/IP体系的应用进程进行标志**
- 需要解决的问题
	- 由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。
	- 有时我们会改换接收报文的进程，但并不需要通知所有发送方。
	- 我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。
- 端口号
	- 解决这个问题的方法就是在运输层使用**协议端口**，或通常简称为**端口port**
	- 虽然通信的终点使应用进程，但我们可以把端口想象使通信的终点，因为我们只要把要传送的报文教到目的主机的魔域一个合适的目的端口，而剩下的工作（即交付目的进程）就由TCP来完成。
- 软件端口与硬件端口
	- 两个不同的概念
	- 在协议栈层间的抽象协议端口是**软件端口**
	- 路由器或交换机的端口是**硬件端口**
	- 硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议与运输实体进行层间交互的一种地址。
- TCP/IP运输层端口
	- 端口用以额16位端口号禁行标志
	- 端口号**只具有本地意义**，即端口号只是**为了标志本计算机应用层中的各进程**
	- 在互联网中，不同的计算机的相同端口号是没有联系的
	- **由此可见，两个计算机中的进程要相互通信，不仅必须知道对方的IP地址（为了找到对方的计算机），而且要知道对方的端口号（为了找到对方计算机中的应用进程）**
- 两大类端口
	- 服务器端使用的端口号
		- 熟知端口，数值一般为0到1023
		- 登记端口号，数值为1024到49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在IANA等级，以防止重复。
	- 客户端使用的端口号
		- 又称为短暂端口号，数值为49152到65535，留给客户进程选择暂时使用。
		- 当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后这个端口号可供其他客户进程以后使用
- 常用的熟知端口
	- ![VN4m2F.png](https://s2.ax1x.com/2019/06/05/VN4m2F.png)


### 用户数据报协议UDP
##### UDP概述
- UDP只在IP的数据报服务之上增加了很少一点的功能：
	- 分用和分用的功能
	- 差错检测的功能
- 虽然UDP用户数据报只能提供不可靠的交付，但UDP在某些方面有其特殊的优点
- UDP的主要特点
	- **UDP是无连接的**，发送数据之前不惜要建立连接，因此减少了开销和发送数据之前的时延。
	- **UDP使用尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态表
	- **UDP是面向报文的**。UDP对应用层教下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP一次交付一个完整的报文
	- **UDP没有拥塞控制**，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多美特通信的要求。
	- **UDP支持一对一，一对多，多对一和多对多的交互通信**
	- **UDP的首部开销小，**只有8个字节，比TCP的20个字节的首部都要短
- 面向报文的UDP
	- 发送方UDP对应用程序教下来的报文，再添加首部后就像下交付IP层。不合并，不拆分
	- 应用层交给UDP多长的报文，UDP就照样发送，即**一次发送一个报文**
	- 接收方UDP对IP层交上来的UDP数据报再取出首部之后就原封不动的交付上层的应用进程，**一次交付一个完整的报文**
	- **应用程序必须选择合适大小的报文**
		- 若报文太长，UDP把他交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。
		- 若报文太短，UDP把它交给IP层后，会使IP数据报的首部相对长度太长，这也降低了IP层的效率。
	- ![VNo4Zd.png](https://s2.ax1x.com/2019/06/05/VNo4Zd.png)
##### UDP的首部格式
- 用户数据报UDP有两个字段：数据字段和首部字段。
- 首部字段很简单，只有8个字节
- ![VNoHRf.png](https://s2.ax1x.com/2019/06/05/VNoHRf.png)
- 当运输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交最后的终点——应用进程
- 请注意，虽然UDP之间的通信要用到其端口号，**但由于UDP的通信是无连接的，因此不需要使用套接字**
- **计算检验和时，临时把“伪首部”和UDP用户数据报连接在一起。伪首部仅仅是为了计算检验和。**

### 传输控制协议TCP概述
##### TCP的主要特点
- **TCP是面向连接的运输层协议**
- 每一条TCP连接**只能有两个端点**，每一条**TCP连接只能是点对点的**（一对一）
- TCP提供**可靠交付**的服务
- TCP提供**全双工**通信
- **面向字节流**
	- TCP中的**流**指的是流入或流出进程的字节序列
	- **面向字节流**的含义是：虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流。
- TCP面向流的概念
	- TCP**不保证**接收方引用程序所收到的数据块和发送方应用程序所发出的**数据块具有对应大小的关系**
	- 但就受访应用程序收到的字节必须和发送方应用程序发送出的**字节流完全一样**
	- ![VNTKW6.png](https://s2.ax1x.com/2019/06/05/VNTKW6.png)
	- ![VNTlQO.png](https://s2.ax1x.com/2019/06/05/VNTlQO.png)
	- TCP**不关心**应用进程一次把多长的报文发送到TCP缓存
	- **TCP对连续的字节流进行分段，形成TCP报文段**
- 注意
	- TCP连接是一条**虚连接**，而不是一条真正的物理连接。
	- TCP对应用进程一次吧多长的报文发送到TCP缓存中是不关心的
	- **TCP根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节。**（UDP发哦那个的报文长度是应用进程给出的）
	- TCP可把太长的数据块划分短一些在传送。
	- TCP也可等待积累有足够多的字节后在构成报文段发送出去。
##### TCP的连接
- TCP把连接作为**最基本的抽象**
- 每一条TCP连接有**两个端点**。
- TCP连接的断点不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议窗口。
	- **TCP连接的端点叫做套接字端口**
- **端口号拼接到IP地址即构成了套接字**
- 套接字socket
	- 每一条TCP连接唯一地被通信两端的两个端点所确定。
	- ![VNThlT.png](https://s2.ax1x.com/2019/06/05/VNThlT.png)
	- ![VNT46U.png](https://s2.ax1x.com/2019/06/05/VNT46U.png)
- TCP连接，IP地址，套接字
	- TCP连接就是由协议软件所提供的一种抽象
	- TCP连接的端点是个很抽象的套接字，即（IP地址：端口号）
	- 同一个IP地址可以有多个不同的TCP连接。
	- 同一个端口号也可以出现在多个不同的TCP连接中。
- Socket有多种不同的意思
	- 应用编程结构API称为Socket API，简称为socket
	- socket API中使用的一个函数名也叫socket
	- 调用socket函数的端点称为socket
	- 调用socket函数时其返回值称为socket描述符，可见成为socket。
	- 在操作系统内核中联网协议的Berkeley实现，称为socket实现

### 可靠传输的工作原理
- 理想传输有以下**两个特点**	
	- 传输信道不产生差错
	- 不管发送方以多块的速度发送数据，接收方总来得及处理收到的数据。
- 在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。
- **然而实际的网络都不具备以上两个理想条件**。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输。
##### 停止等待协议
- 停止等待就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。
- **全双工通信的双方及时发送方也是接收方**
- 为了讨论问题的方便，我们进考虑A发送数据，而B接收数据并发送确认。因此A叫做发送方，B叫做接收方
- 无差错情况
	- A发送分组M1，发完就暂停发送，等待B确认(ACK)。B收到了M1向A发送ACK。A在收到对M1的确认后，就再发送下一个分组M2。
	- ![VN7Vc8.png](https://s2.ax1x.com/2019/06/05/VN7Vc8.png)
- 出现差错
	- 在接受方B会出现两种情况
		- B接收M1时检测出了差错，就丢弃M1，其他什么也不做（不发送ACK）
		- M1在传输过程中丢失了，这时也什么都不做。
	- 在这两种情况下，B都不会发送任何信息
	- 如何保证B正确收到了M1呢？
	- 解决方法：超时重传
		- A为每一个已发送的分组都设置了一个**超时计时器**。
		- A只要在超世纪时期到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组M2。
		- ![VN7dE9.png](https://s2.ax1x.com/2019/06/05/VN7dE9.png)
- 确认丢失和确认迟到
	- 确认丢失
		- 若B所发送的对M1的确认丢失了，那么A在设定的超时时间内不能收到确认，但A并无法知道：是自己发送的分组出错了，丢失了，或者是B发送的确认丢失了。因此**在A超时计时器到期后就要重传M1**
		- 假定B又收到重传的M1，采取两个行动
			- 第一，**丢弃这个重发的分组M1**，不向上层交付
			- 第二，**向A发送确认**。不能认为已经发送过的确认就不在发送
	- 确认迟到
		- 传输过程中没有差错，但B对分组M1的确认迟到了
		- A收到重复的确认。对重复的确认很简单，手下后就丢弃。
		- B仍然会收到重复的M1，并且同样套丢弃重复的M1，并重传确认分组。
	- ![VN7I8P.png](https://s2.ax1x.com/2019/06/05/VN7I8P.png)
	- 再发送玩一个分组后，必须**暂时保留已发送的分组的副本**，以备重发
	- **分组和确认分组都必须进行编号。**
	- 超时计时器的重传时间应当比数据在分组传输的平均往返时间**更长一些**
- 自动重传请求ARQ
	- **通常A最终总是可以收到对所有发出的分组确认**。如果A不断重传分组但总是收不到确认，说明线路太差，不适合通信。
	- 使用上述的确认和通信机制，我们就可以在不可靠的传输网络上实现可靠的通信。
	- **像上述的这种可靠传输协议常称为自动重传请求ARQ**。意思时重传的请求时自动运行的，接收方不需要请求发送方重传某个出错的分组。
- 信道利用率
	- 停止等待协议的优点是简单，缺点是信道利用率太低。
	- ![VN7bDg.png](https://s2.ax1x.com/2019/06/05/VN7bDg.png)
	- 可以看出，当往返时间RTT远大于分组发送时间TD时，信道的利用率就会非常低。
- 流水线传输
	- 为了提高效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。
	- **流水线传输**就是发送方可连续发送多个分组，不必每发完后一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。
	- 由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。
##### 连续ARQ协议
- 滑动窗口协议比较复杂，是TCP协议的精髓所在。
- 发送方维持的发送窗口，他的意思是：**位于发送窗口内的分组都可连续发送出去，而不需要等待对方确认。**
- 连续ARQ协议规定，**发送方没收到一个确认，就把发送窗口向前滑动一个分组的位**
- ![VNbB6K.png](https://s2.ax1x.com/2019/06/05/VNbB6K.png)
- 累计确认
	- 接收方一般采用**累计确认**方式，即不必对收到的分组逐个发送确认，**而是对按需到达的最后一个分组发送确认**，这样就表示：**到这个分组为止的所有分组都已正确收到了**
	- 优点：容易实现，技术确认丢失也不必重传
	- 缺点：不能向发送方反映出接收方已经正确收到的所有分组信息。
- Go-back-N
	- 如果发送方发送了前五个分组，而中间的第三个分组丢失了。这是接收方只能对前两个分组进行确认。发送方无法知道后面三个分组的下落，而**只好把后面的三个分组都在重传一次**
	- 这就叫做go-back-N（回退N），表示西药在退回来重传已发送过的N个分组
	- 可见通信线路质量不好时，连续ARQ协议会带来负面影响。
- TCP可靠通信的具体实现
	- TCP连接的每一端都必须设有两个窗口——一个**发送窗口**，一个**接收窗口**
	- TCP的可靠传输机制用**字节的序号**进行控制，TCP所有的确认都是基于序号而不是基于报文段
	- TCP两端的四个窗口经常处于**动态变化**之中
	- TCP连接的往返时间RTT也不是固定不变的。需要使用特定的算法**估算较为合理的重传时间**

### TCP报文的首部格式
- TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段
- 一个TCP报文段分为首部和数据两部分，而TCP的全部功能都替此案在它首部中各字段的作用
- TCP报文段首部的前20个字节时固定的，后面有4n个字节是根据需要而增加的选项。因此TCP首部的最小长度为20字节。
- ![VNqVc6.png](https://s2.ax1x.com/2019/06/05/VNqVc6.png)
	- 源端口和目的端口字段：各占2个字节。端口是运输曾于应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现
	- 序号字段：占4个字节。TCP连接中传送的数据流中的每一个字节都编上一个序号，序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。
	- 确认号字段：占4个字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。
	- 数据偏移：即首部长度，占4位，他指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，数据偏移的单位是32位字（以4字节为计算单位）
	- 保留字段：占6位，目前应置为0，为今后使用
	- 紧急URG：当 URG=1 时，表明紧急指针字段有效。它高斯系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）
	- 确认ACK：只有当 ACK=1 时确认号字段才有效，当 ACK=0 时，确认好无效。
	- 推送PSH：接收TCP收到PSH=1的报文段，就尽快的交付接受应用进程，而不在等到整个缓存都填满了后再向上交付。
	- 复位RST：当RST=1时，表明TCP连接出现严重差错,必须释放连接，然后再重新建立运输连接。
	- 同步SYN：当SYN=1时，表示这是一个连接请求或连接接收报文。
	- 中使FIN：用来释放一个连接，FIN=1表名此报文段的发送端的数据已发送完毕，并要求释放运输连接
	- 窗口字段：占2字节，用来让对方设置发送窗口的一句，单位为字节。
	- 检验和：占2字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在TCP报文段的前面加上12字节的伪首部
	- 紧急指针字段：占2字节，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报问段数据的最前面）
	- 选项字段：长度可变。TCP最初只规定了一种选项，即最大报文长度MSS。MSS高速对方TCP缓存所能接收的最大长度时MSS个字节	
		- MSS是TCP报文段中**数据字段**的最大长度。数据字段加上TCP首部才等于整个的TCP报文段。所以MSS是TCP报文段长度减去TCP首部长度。
- 为什么要规定MSS
	- **MSS与接收窗口值没有关系**
	- **若选择较小的MSS长度，网络的利用率就降低**
	- 当TCP报文段**只含有1字节数据时**，在IP层传输的数据报开销至少有40字节（包括TCP首部和IP首部）。这样对网络的利用率就不会超过1/41
	- 若TCP报文段非常长，那么IP层传输时就可能要分解成多个短数据报片。在IP岑传输时就要被啊收到的各个短数据报片装配成原来的TCP报文段。当传输出错时还要进行重传。这写也都会使开销增大。
	- 因此MSS应尽可能大些，只要IP层传输时不需要在分片就行。
	- 由于IP数据报所经历的路径时动态变化的，因此在这条路径上确定的不需要分片的MSS，如果走另一条路线就可能要分片
	- 因此**最佳MSS是很难确定的**


### TCP可靠传输的实现
##### 以字节为单位的滑动窗口
- TCP的滑动窗口是以字节为单位的
- 现假定A收到了B发来的确认报文段，其中窗口是20字节，而确认号是31（这表明期房收到的下一个序列号是31，而序号30为止的数据已经收到了。）
- 根据这两个数据，A就构造出自己的发送窗口。
- ![VNj1Z8.png](https://s2.ax1x.com/2019/06/05/VNj1Z8.png)
- ![VNjNzn.png](https://s2.ax1x.com/2019/06/05/VNjNzn.png)
- ![VNjWsx.png](https://s2.ax1x.com/2019/06/05/VNjWsx.png)
- ![VNj4eK.png](https://s2.ax1x.com/2019/06/05/VNj4eK.png)
- 发送缓存和接受缓存的作用
	- 发送缓存用来暂时存放
		- 发送应用程序传送给发送方TCP准备发送的数据；
		- TCP已发送处但尚未收到确认的数据。
	- 接收缓存用来暂时存放：
		- 按序到达的，但尚未被接受应用程序读取的数据；
		- 不按序到达的数据
- 需要强调的三点
	- 第一，A的发送窗口并不总是和B的接收窗口一样大（因为有一定的时间滞后）
	- 第二，TCP标准没有规定对不按序道德数据应如何处理，通常是先临时存放到接收窗口中，等到字节流中缺少的字节流收到后，再按序交付上层的应用进程。
	- 第三，TCP要求接收方必须有立即确认的功能，这样可以减少传输开销。
- 接收方发送确认
	- 接收方可以**再合适的时候发送确认**，也可以在自己有数据要发送时把确认信息**顺便捎带上**
	- 但是要注意两点
		- 接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络资源
		- 捎带确认实际上并不经常发生，因为大多数的应用程序很少的同时在两个方向上发送数据
##### 超时重传时间的选择
- 重传机制是TCP中最重要和最复杂的问题之一。
- TCP每发送一个报文段，就对这个报文段设置一次计时器
- 只要计时器设置的重传时间到但还没有收到确认，就重传这一报文段
- **重传时间的选择是TCP最负责问题之一**
- TCP超时重传时间设置
	- 如果把超时重传时间设置的太短，就会引起很多报文段的不必要重传，使网络负荷增大
	- 但若把超时重传时间设置的过长，则又使网络的空闲时间增大，降低了传输效率。
	- **TCP采用了一种自适应算法**，他记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间RTT.
- 加权平均往返时间
	- TCP保留了RTT的一个加权平均往返时间RTTs（又称为平滑的往返时间）
	- 第一次测量到RTT样本时，RTTs值就取为所测量的RTT样本值，以后每测量到一个新的RTT样本，就按下式重新计算一次RTTs：
		- ![VUeYHe.png](https://s2.ax1x.com/2019/06/05/VUeYHe.png)
		- 式中a接近于0，则表示RTT值更新的满。
		- RFC 2998推荐 **a = 0.125**
- 超时重传时间RTO
	- RTO应略大于上面的出的加权平均时间RTTs
	- 计算公式为
		- ![VUej81.png](https://s2.ax1x.com/2019/06/05/VUej81.png)
	- RTTd是RTT的偏差加权平均值
	- 第一次测量时，RTTd取RTT的样本值的一般，以后按下面的公式测量
		- ![VUm9bD.png](https://s2.ax1x.com/2019/06/05/VUm9bD.png)
		- b是个小于1的系数，**推荐0.25**
##### 选择确认SACK
- 到的报文无差错，只是未按序号，中间还缺少一些序号的而数据，只传送缺少的数据而补充穿已经正确到达的数据。**用算则确认SACK处理方法**
- ![VUn50U.png](https://s2.ax1x.com/2019/06/05/VUn50U.png)
- 接收方收到了和前面的字节流不连续的两个字节块
- 如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，**但要把这些信息准确地告诉发送方，使发送方不不要再重复发送这些已收到的数据**
- RFC 2018的规定
	- 如果要使用选择确认，那么在建立TCP连接时，就要在TCP首部的选项中加上“允许SACK”的选项，而双方必须都事先商定好。
	- 如果使用选择确认，那么原来首部中的确认号字段的用法仍然不变，只是以后再TCP报文段的首部中都增加了SACK选项，以便报告收到的不连续的字节块的边界
	- 由于首部选项的长度最多只有40字节，而指明一个边界就要用到4个字节，因此在选项中最多只能指明4个字节快的边界信息

### TCP的流量控制
##### 利用滑动窗口实现流量控制
- 一般说来，我们总是希望数据传输的更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。
- **流量控制**就是让发送方的发送速率不要太快，及要让接收方来得及接收，也不要使网络发生拥塞。
- 利用**滑动窗口机制**可以很方便的在TCP连接上实现流量控制
- ![VUKhoF.png](https://s2.ax1x.com/2019/06/05/VUKhoF.png)
- 可能发生死锁
	- B向A发送了零窗口的报文段后不久，B的接受缓存又有了一些存储空间。于是B向A发送了rwnd = 400的报文段。
	- 但是这个报文段在传送过程中**丢失**了。A一直等待收到的B发送的非零窗口的通知，而B也一直等待A发送的数据
	- 为了解决这个问题，TCP为每一个连接设有一个**持续计时器**
- 持续计时器
	- TCP为每一个连接设有一个持续计时器
	- 只要TCP连接的乙方收到对方的**零窗口**就启动该持续计时器
	- 若持续计时器设置的时间到期，就发送一个零窗口探测报文段(仅1字节的数据），而对方就在确认这个探测报文段时给出了现在的串口值
	- 若窗口仍然为0，则收到这个报文段的一方就重新设置持续计时器。
	- 若窗口不是0，则死锁的僵局就可以打破了
##### TCP的传输效率
- 可以用不同的机制来控制TCP报文的发送时机
	- 第一种机制是TCP维持一个变量，它等于最大报文段的长度MSS。只要缓存中存放的数据到达MSS字节时，就组装成一个TCP报文段发出去。
	- 第二种机制是由发送发的应用进程指明要求发送的报文段，即TCP支持的推送操作。
	- 第三种机制是发送方的一个计时器的期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过MSS）发送出去。
- 如何控制TCP发送报文段的实际仍然是一个比较复杂的问题


### TCP的拥塞控制
##### 拥塞控制的一般原理
- 在某段时间，若对网络中某资源的需求超过了该资源索嫩提供的可用部分，网络的性能就要变坏。这种现象称为**拥塞**。
- 若网络中有许多资源同时产生拥塞，网络的性能就要明显的变坏，整个网络的吞吐量将随着输入负荷的增大而下降。
- 出现拥塞的原因
	- ![VUYAiV.png](https://s2.ax1x.com/2019/06/05/VUYAiV.png)
- **增加资源不能解决拥塞**
	- 网络拥塞是一个非常复杂的问题。简单的采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。
	- 网络拥塞往往是由许多因素引起的，例如：
		- 增大缓存，单位提高输出链路的容量和处理及的速度，排队等待时间将会大大增加，引起大量的超时重传，解决不了网络拥塞；
		- 提高处理及处理的速率会将瓶颈转移到其他的地方
- 拥塞常常趋于恶化
	- 如果一个路由器没有足够的缓存空间，他就会丢弃一些新到的分组。
	- 但当分组被丢弃时，发送者一分组的源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃
	- **可见拥塞引起的重传并不会环节网络的拥塞，反而会加剧网络的拥塞。**
- 拥塞控制和流量控制的区别
	- **拥塞控制**就是防止过多的数据注入到网络中，使网络中的路由器或链路不至过载
	- **拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷**
	- **拥塞控制**是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能的所有因素。
	- **流量控制**往往指点对点通信量的控制，是个端到端的问题
	- **流量控制**所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。
	- 拥塞控制和流量控制之所以经常被弄混，是因为某些拥塞控制算法是像发送端发送控制保报文，并告诉发送端，网络已经出现麻烦，必须放慢发送速率。这点又和流量控制是很相似的。
- 拥塞控制所起的作用
	- ![VUtQXQ.png](https://s2.ax1x.com/2019/06/05/VUtQXQ.png)
- 拥塞控制的一般原理
	- 实践证明，拥塞控制是很难设计的，因为他是一个**动态的问题**
	- 当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组丢失。**但分组的丢失是网络发生拥塞的征兆而不是原因**
	- **在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因**
- 开环控制和闭环控制
	- 开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞
	- 闭环控制方法是基于反馈环路的概念。属于闭环控制的有以下几种措施
		- 检测网络系统以便检测到拥塞在何时何处发生
		- 将拥塞发生的信息传送到可采取行动的地方
		- 调整网络系统的郧西那个以解决出现的问题。
- 检测网络的拥塞的指标
	- 由于缺少缓存空间而被丢弃的分组的百分数
	- 平均队列长度
	- 超时重传的分组数
	- 平均分组时延
	- 分组时延的标准差，等等
	- 上述这些指标的上升都标志拥塞的增长
##### TCP的拥塞控制方法
- **TCP采用基于窗孔的方法进行拥塞控制，该方法属于闭环控制方法**
- TCP发送方维持一个拥塞窗口CWND
	- 拥塞窗口大小取决于网络的拥塞程度，并且动态地在变化。
	- 发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量
	- 所以，发送窗口的大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况
	- 所以真正的发送窗口值为
		- ![VUNQC6.png](https://s2.ax1x.com/2019/06/05/VUNQC6.png)
- 控制拥塞窗口的原则
	- 只要网络没有出现拥塞，拥塞窗口就可以在增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率
	- 但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以缓解网络出现的拥塞。
- 拥塞的判判断
	- 重传定时器超时
		- 现在通信线路的传输质量一般都很好，因此传输出差错而丢弃的分组的概率是很小的。只要出现了超时，就可以猜想网络出现了拥塞
	- 收到三个相同的ACK
		- 个别报文会在网络中丢失，预示着可能会出现拥塞（实际上并未发生），因此可以尽快采取控制措施，避免拥塞
- TCP拥塞控制算法（四种）
	- 慢开始
	- 拥塞避免
	- 快重传
	- 快恢复
- 慢开始
	- 用来确定网络的负载能力
	- **算法的思路：由小到大逐渐增大拥塞窗口的数值**
	- 初始拥塞窗口cwnd设置
		- 旧的规定：在刚刚开始发送报文段时，先把初始拥塞窗口cwnd设置为1到2个发送方的最大报文段SMSS的数值
		- 新的规定：设置为不超过2个到4个SMSS的数值。
	- 慢开始门限：防止拥塞窗口cwnd增长过大引起网络拥塞。
	- 拥塞窗口cwnd的控制方法：再没收到一个对新的报文段的确认后，可以把拥塞窗口增加最多一个SMSS的数值。
		- ![VUNR5q.png](https://s2.ax1x.com/2019/06/05/VUNR5q.png)
	- 其中N是原先为被确认的，但现在被刚收到的确认报文段所确认的字节数。
	- 不难看出，当N小于SMSS时，拥塞窗口每次的增加量要小于SMSS
	- 用这样的方法逐步增大发送方的拥塞窗口cwnd，可以使分组注入到网络的速率更加合理。
	- ![VUUVRf.png](https://s2.ax1x.com/2019/06/05/VUUVRf.png)
- 传输轮次
	- 使用慢开始算法后，每经过一个传输轮次，拥塞窗口cwnd就加倍。
	- 一个传输轮次所经历的时间其实就是往返时间RTT
	- 传输轮次更加强调把拥塞窗口cwnd所允许发送的报文段都连续的转发出去，并受到了对已发送的最后一个字节的确认。
	- 例如，拥塞窗口cwnd=4，这时的往返时间RTT就是发送方连续发送4个报文段，并收到4个报文段的确认，总共经理的时间
- 设置满开始们先状态变量ssthresh
	- 慢开始门限ssthresh的用法如下：
		- 当cwnd<ssthresh时，使用慢开始算法。
		- 当cwnd>ssthresh时，停止使用慢开始算法而改用拥塞避免算法。
		- 当两则相等时，那种算法都行。
- 拥塞避免算法
	- 思路：让拥塞窗口**缓慢的增大**，即每经过一个往返时间RTT就把发送窗口cwnd加1，而不是加倍，使拥塞窗口按先行规律缓慢增长。
	- 因此再拥塞避免阶段就由加法增大的特点，这表明在拥塞避免阶段，拥塞窗口cwnd按先行规律增长，比慢开始增长速率缓慢的多。
- 当网络出现拥塞时
	- 无论在满开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时，三次相同ACK）
		- ssthresh = max（cwnd/2，2）
		- cwnd=1
		- 执行慢开始算法
	- 这样做的目的就是要迅速减少主机网络发送到网络中的分组数，使得发生用色的路由器有足够的时间把队列中的挤压的分组处理完毕。
	- ![VUDlo4.png](https://s2.ax1x.com/2019/06/05/VUDlo4.png)
	- 当TCP连接进行初始化时，将拥塞窗口设置为1，图中的窗口单位不适用字节而使用报文段。
	- 慢开始门限初始值设置为16个报文段，即ssthresh = 16
	- 发送窗口不能超过拥塞窗口cwnd和接收端窗口rwnd的最小值。我们假定接收窗口足够大，因此现在发送窗口的数值等于拥塞窗口的数值
	- 发送方每收到一个对新报文段的确认，就把拥塞窗口的值加1，然后开始下一轮的传输，横坐标是传输轮次，不是时间。
	- 当拥塞窗口cwnd增长到慢开始门限值ssthresh时，就执行拥塞避免算法。线性增长。
	- “拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的
	- “拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，**使网络比较不容易出现拥塞**
	- 当拥塞窗口 cwnd = 24 时，网络出现了超时，发送方判断为网络拥塞。于是调整门限值 ssthresh = cwnd / 2 = 12，同时设置拥塞窗口 cwnd = 1，进入慢开始阶段
	- 按照慢开始算法，发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值加1。当拥塞窗口cwnd = ssthresh = 12时（这是新的ssthresh值），改为执行拥塞避免算法，拥塞窗口按线性规律增大
	- 当拥塞窗口cwnd = 16时（图中的点），出现了一个新的情况，就是发送方一连收到 3 个对同一个报文段的重复确认（图中记为3-ACK）。发送方改为执行**快重传和快恢复算法**
- 快重传算法
	- 采用快充穿FR算法可以让发送方今早知道发生了个别报文段的丢失。
	- 快重传算法首先要求接收方不要等待自己发送数据时才进行稍待确认，而是要立即发送确认，及时收到了失序的报文也要立即发送对已收到的报文段的确认。
	- **发送方只要一连收到三个重复确认**，就知道接收方确实没有收到报文段，因而应当**立即执行重传**，这样就不会出现网络超时。
	- **不难看出快重传并非取消重传计时器而是在某些情况下可更早的重传丢失的报文段**
	- 如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认
	- ![VUrE7D.png](https://s2.ax1x.com/2019/06/05/VUrE7D.png)
- 快恢复算法
	- 当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法
		- 慢开始门限ssthresh = 当前cwnd/2
		- 新cwnd = 慢开始门限ssthresh
		- 开始执行拥塞避免算法，使拥塞窗口缓慢的线性增加。
- 所有这些算法放在一起叫做**加法增大，乘法减小AIMD算法**。
- 发送窗口的上限值
	- ![VUrthj.png](https://s2.ax1x.com/2019/06/05/VUrthj.png)
	- **也就是说rwnd和cwnd中数值叫小的一个控制了发送方数据发送速率。**


### TCP的运输连接管理
- TCP是面向连接的协议。
- 运输连接有三个阶段
	- **连接建立**
	- **数据传送**
	- **连接释放**
- **运输连接的管理**就是使运输连接的建立和释放都能正常的运行
- TCP连接建立过程中要解决的三个问题
	- 要使每一方能够准确知道对方的存在
	- 要允许双方协商一些参数（如窗口最大值，是否适用窗口扩大选项，和时间戳选项以及服务质量等）
	- 能够对运输实体资源（缓存大小，连接表中的项目等）进行分配
- 客户-服务器方式
	- TCP连接的建立采用**客户服务器方式**
	- 主动发起连接建立的应用进程叫做**客户(client）**
	- 被动等待连接建立的应用进程叫做**服务器(server)**
##### TCP连接的建立
- TCP建立连接的过程叫做**握手**
- 握手需要在客户和服务器之间交换三个TCP报文段，称之为**三报文握手**
- 采用**三报文握手**主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。
	- ![VUsiCj.png](https://s2.ax1x.com/2019/06/05/VUsiCj.png)
	- ![VUsk2n.png](https://s2.ax1x.com/2019/06/05/VUsk2n.png)
	- ![VUsebT.png](https://s2.ax1x.com/2019/06/05/VUsebT.png)
	- B的TCP主机收到A的确认后，也通知其上层应用进程：TCP连接已经建立。
##### TCP连接的释放
- TCP连接释放的过程比较复杂
- 数据传输接结束后，通信的双方都可释放连接
- TCP俩姐释放的过程是**四报文握手**
	- ![VUsQPJ.png](https://s2.ax1x.com/2019/06/05/VUsQPJ.png)
	- ![VUssMt.png](https://s2.ax1x.com/2019/06/05/VUssMt.png)
	- ![VUs2dS.png](https://s2.ax1x.com/2019/06/05/VUs2dS.png)
	- ![VUshGj.png](https://s2.ax1x.com/2019/06/05/VUshGj.png)
	- ![VUsqdU.png](https://s2.ax1x.com/2019/06/05/VUsqdU.png)
- TCP连接必须经过实践2MSL后才真正释放掉
	- 第一，为了保证A发送的最后一个ACK报文能够到达B
	- 第二，防止“已失效的连接请求报文段”出现在本连接中。A再发送完最后一个ACK报文段后，在经过2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。