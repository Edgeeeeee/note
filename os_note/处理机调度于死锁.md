# 处理机调度与死锁
- 处理机是系统中的**重要资源**
- 再多道程序环境下，**进程数目通常多于处理机数目**
- 系统必须按一定方法**动态地**把处理机**分配**给就绪队列中的一个进程
- 处理机**利用率和系统性能**（吞吐量，响应时间）在很大程度上**取决于处理机调度**


## 调度的类型和模型
	- 从处理机调度的对象，时间，功能等不同角度，我们可以把处理机调度分成不同类型；
		- 按OS的类型分类，分为批处理，分时，实时
		- 按调度层次分类分为高级调度，中级调度，和低级调度（微观调度）
		- 长期，中期，短期和I/O调度

- 按照调度的层次
	- 作业调度：又称为宏观调度，高级调度。从用户工作流程的角度，一次提交若干个流程，其中每个程序按照进程调度
		- **多道程序度：即允许多少个作业同时在内存中运行**
		- **周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔**
		- **吞吐量：是指在单位时间内系统所完成的作业数量**
	- 内外存交换：又称为“中级调度”。从存储器资源的角度。将进程的部分或全部全部换出到外存上，将当前所需部分换入内存。指令和数据必须在内存里才能被CPU直接访问
		- 引入目的是为了提**高内存利用率**和**系统吞吐量**。
		- **主要任务**是按照给定的**原则和策略**，将处于外存**对换区**中的重要又具备运行条件的就绪进程**调入内存**，或将处于内存就绪状态或内存阻塞状态的进程**交换到外存**的交换区
	- 进程或线程：又称为微观调度，低级调度。从CPU资源的角度，执行的单位。因为执行频繁，要求在是现实达到高效率
- 非抢占方式
	- 在采用非抢占调度方式时，可能引起进程调度的因素可归结为这样几个：
		- 正在执行的进程执行完毕，或因发生某事件而不能在继续执行；
		- 执行中的进程因题除I/O请求而暂停执行；
		- 在进程通信或同步过程中执行了某种原语操作
		- 实现简单，系统开销小，适用于大多数的批处理系统环境。但它难以满足紧急任务的要求：立即执行
- 抢占方式
	- 原则
		- 优先权原则
		- 短作业（进程）优先原则
		- 时间片原则
- 进程调度
	- 进程调度的功能：
		- 记录所有进程的运行情况（静态和动态），当进程出让CPU或调度程序剥夺执行状态进程占用的CPU时，选择适当的进程分派CPU，完成上下文的切换
	- 进程的上下文切换过程是：
		- 用户态执行进程A代码
		- 保存A的上下文，恢复B进程的上下文
		- 用户态执行B代码
- 调度队列模型（三种）
	- 仅有进程调度的调度队列模型
		- 分时系统
		- 单就绪，单阻塞队列
		- ![EHfD4x.png](https://s2.ax1x.com/2019/05/16/EHfD4x.png)
	- 具有高级和低级的调度队列模型
		- 进程调度，作业调度
		- 根据阻塞原因设置多个阻塞队列
		- [![EHfWbd.md.png](https://s2.ax1x.com/2019/05/16/EHfWbd.md.png)](https://imgchr.com/i/EHfWbd)
	- 同时具有三级调度的调度队列模型
		- 增加挂起队列
		- ![EHfvan.png](https://s2.ax1x.com/2019/05/16/EHfvan.png)
- 选择调度方式和算法的若干准则
	- 可从不同的角度来判断处理机调度算法的性能，如用户的角度，处理机的角度和算法实现的角度。
	- 面向用户的调度性能准则
		- 周转时间
			- 批处理系统的重要指标。作业从提交到完成所经历的时间。
			- 平均周转时间
				- ![EHjkp4.png](https://s2.ax1x.com/2019/05/16/EHjkp4.png)
			- 带权周转时间
				- ![EHjA1J.png](https://s2.ax1x.com/2019/05/16/EHjA1J.png)
		- 响应时间：
			- 用户输入一个请求到系统给出首次响应的时间
			- 包括：从终端的键盘输入的一个请求信息传送到处理机的时间；处理机对请求的处理时间；处理结果送到终端显示器的时间
		- 截止时间
			- 实时系统的重要指标
			- 开始截止时间：某个任务在开始截止时间前必须开始
			- 完成截止时间：某个任务在完成截止时间前必须完成
		- 公平性
			- 不因作业或进程本身的特性而使上述指标过分恶化
		- 优先级
	- 面向系统的调度性能准则
		- **吞吐量**：
			- 单位时间内完成的作业数
			- 注意：平均周转时间不是吞吐量的倒数，因为并发执行的作业在时间上可以重叠
		- 处理机利用率：
		- 各种设备的均衡利用
## 调度算法
- 调度算法 = 资源分配策略
	- 调度通常指将作业或进程归入各种就绪或阻塞队列。有的调度算法适用于作业调度，有的算法适用于进程调度，有的两者都适应
- 调度的时机
	- 一般与调度方式有关
	- 正在执行的进程正常结束或由于某种错误而中止运行
	- 执行中的进程提出I/O请求，在I/O完成之前，进程阻塞，转进程调度
	- 在分时系统中，按照时间片轮转，分给进程的时间片用完时
	- 按照优先级调度，有更高的优先级变为就绪时
	- 在进程通信中，执行了某种原语操作（例如wait，block）
- 先来先服务算法：按先后顺序进行调度（FCFS）
	- 按照作业提交或进程变为就绪的状态的先后次序来选择
	- 当前进程占用CPU，直到执行完或阻塞，才让出CPU（非抢占方式）
	- 在唤醒进程中，并不立即恢复执行，通常等到当前进程出让CPU
	- ![EHxFy9.md.png](https://s2.ax1x.com/2019/05/16/EHxFy9.md.png)
	- 特点
		- 比较有利于长作业而不利于短作业，有利于CPU繁忙的作业，不利于I/O繁忙的作业
		- 对短作业而言，带权周转时间可能太大
- 短作业（进程）优先调度
	- 对FCFS算法的改进，其目标是减少平均周转时间
	- 根据进程下次使用CPU的时间排序，使用CPU时间短的进程先执行
	- 两种实现方法
		- 非抢占式——不能抢夺其他进程对CPU 的使用，只能由进程主动放弃CPU 
		- 抢占式——如果由一个使用CPU时间更短的进程到达就绪队列，就抢占他的CPU。这种调度方案称为**最短剩余时间优先**
	- 非抢占式
	- ![EHzKA0.png](https://s2.ax1x.com/2019/05/16/EHzKA0.png)
- 时间轮转调度算法（时间片法）
	- 前两中用于宏观调度，此算法用于微观调度，目标是提高资源利用率。、
	- 其基本思路是通过实践篇轮转，提高进程并发性和响应时间的特性，从而提高资源利用率
	- 算法描述
		- 将系统中所有的就绪进程按照FCFS原则排成一个队列
		- 每次调度将CPU分派给队首进程，让其执行一个时间片。事件篇的长度从几个ms到几百ms
		- 在一个时间片结束时，发生时钟中断
		- 调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程
		- 进程可以未使用完一个时间片就出让CPU
		- **教材案例，插入位置**
	- 时间片长度的确定
		- 过长：退化为FCFS算法，进程在一个时间片内全部完成，响应时间长
		- 过短：用户的一次请求需要多个时间片才能处理完，上下文切换次数增加，响应时间长
		- 对响应时间的要求：T（响应时间） = N（进程数目） * q（时间片）
		- 就绪进程的数目：数目越多，时间片越小
		- 系统的处理能力：应当使用用户输入通常在一个时间片内能处理完，否则使响应时间，平均周转时间和平均带权周转时间延长。
- 多级队列调度算法
	- 引入多个就绪队列，通过对各个队列的区别对待，达到一个综合的调度目标
		- 根据作业或进程的性质或类型的不同，将就绪队列再分为若干个子队列。
		- 每个作业固定归入一个队列
		- 不同队列可以有不同的优先级，时间片长度，调度策略等；在运行过程中还可改变进程所在队列。
	- 队列之间需要采用某种调度算法：
		- 固定优先权（例如前台高于后台）：可能会引起饿死现象
		- 划分时间片：每个队列分得一定的CPU时间，在分得的时间内，调度各自队列中的进程。
- 优先权调度算法
	- 本算法是多级队列算法的改造，平衡各进程对响应时间的要求。适用于作业调度和进程调度
	- 分为**抢占式**和**非抢占式**
		- 抢占式：当前的进程在其时间片未用完时就可被优先级更高的进程抢用CPU。
		- 非抢占：自愿释放CPU
- 优先权的类型
	- 静态优先级
		- 创建进程时就确定，直到进程中止前都不改变。通常是一个整数，依据
			- 进程类型（系统进程优先级较高）
			- 对资源的需求（对CPU和内存需求较小的进程，优先级较高）
			- 用户要求（紧迫成都和付费多少）
	- 动态优先级
		- 在创建进程时赋予的优先级，在进程运行过程中可以自动改变，以获得更好的调度性能
			- 在就绪队列中，等待时间延长则优先级提高，从而使优先级较低的进程在等待组后的时间后，其优先级提高到可调度执行
			- 进程每执行一个时间片，就降低其优先级，从而一个进程持续执行时，其优先级降低到出让CPU
- 多级反馈队列调度算法
	- 优点
		- 为提高系统吞吐量和缩短平均周转时间而照顾短进程
		- 为获得较好的I/O设备利用率和缩短响应时间而照顾I/O进程
		- 不必估计执行的时间，动态调节
	- 仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾
## 实时调度
- 实现实时调度的基本条件
	- 提供必要的信息
		- 开始截止时间和完成截止时间
		- 就绪时间，该任务成为就绪状态的起始时间
		- 处理时间
		- 资源要求
		- 优先级
	- 系统处理能力强
		- 再实时系统中，通常都有着多个实时任务。若处理及的处理能力不够强，则有可能因**处理机忙不过来**而使某些实时任务不能得到及时的处理，从而导致难以预料的后果。假定有m各周期性的硬实时任务，他们的**处理时间**可表示为Ci，周期时间表示为Pi，则在单处理及的情况下必须满足下面的限制
		- ![EbkX1x.png](https://s2.ax1x.com/2019/05/16/EbkX1x.png)
		- 若上式不满足则系统是不可调度的
		- **解决的方法**是提高系统的处理能力
			- 采用单处理机系统，但需增强其处理能力，以显著地减少对每一个任务的处理时间
			- 蚕蛹多处理机系统 ，假定系统中的处理机数位N，则应该将上述的限制条件改为
			- ![EbA8g0.png](https://s2.ax1x.com/2019/05/16/EbA8g0.png)
	- 采用抢占式调度机制
	- 具有快速切换机制，该机制应具有如下两方面的能力
		- 对外部中断的**快速响应**能力
			- 卫视在紧迫的外部事件中请求中断时系统能**及时响应**，要求系统具有快速**硬件中断机构**，还应使禁止中断的时间间隔尽量短，以免耽误时机（其他紧迫任务）
		- **快速**的任务分派**能力**
			- 在完成任务调度后，便应进行**任务切换**，为了提高分派程序进行任务切换时的速度，应时系统中的**每个运行功能单位适当的小**，以减少任务切换的时间开销
- 实时调度算法的分类
	- 非抢占式调度算法（实时任务小）
		- **非抢占式轮转调度算法**
			- 常用于工业生产的群控制系统中
			- 调度程序每次选择队列中的第一个任务运行
			- 一个任务运行后，排在轮转队列的末尾，等待下次调度
		- **非抢占式优先调度算法**
			- 为时间要求严格的任务分配较高的优先级
			- 当优先权高的实时任务到来时，排在**就绪队列**的队首等待调度
	- 抢占式调度算法
		- 基于时钟中断的抢占式优先权调度算法
			- 某实时任务到达后，若优先级高于当前正在执行任务的优先级，并不是立即抢占当前任务的处理机，而是等到时钟中断到来后，调度程序才剥夺当前任务的执行
		- 立即抢占的优先权调度算法
			- 一旦有外部中断，只要**当前任务不在临界区内**，便立即剥夺当前任务的执行，将处理机分配给要求中断的紧迫任务
- 常用的几种实时调度算法
	- 最早截止时间优先EDF算法
		- 根据任务的**开始截止时间完成截止时间**来确定任务的优先级，**截止时间越早，优先级越高**
		- 即可用于抢占式调度，也可用于非抢占式调度
		- ![Eb2DYV.png](https://s2.ax1x.com/2019/05/16/Eb2DYV.png)
		- 抢占式调度用于周期实时任务
			- ![EbRk0s.png](https://s2.ax1x.com/2019/05/16/EbRk0s.png)
		- 固定优先级调度，
			- A具有较高优先级
				- [![EbWl28.md.png](https://s2.ax1x.com/2019/05/16/EbWl28.md.png)](https://imgchr.com/i/EbWl28)
			- B具有较高优先级
				- ![EbWbdA.png](https://s2.ax1x.com/2019/05/16/EbWbdA.png)
		- 最早截止完成时间优先算法
			- ![EbfVzT.png](https://s2.ax1x.com/2019/05/16/EbfVzT.png)
			- ![EbftyD.png](https://s2.ax1x.com/2019/05/16/EbftyD.png)
	- 最低松弛度优先算法
		- 实例：一个实时系统中，有两个周期性实时任务和A和B，任务A要求没20ms执行一次，执行时间为10ms；任务B只要求每50ms执行一次，执行时间为25ms
		- 处理能力需求：10/20 + 25/50 = 1
		- 松弛度 = 必须完成时间 - 其本身的运行时间 - 当前时间
			- t1 = 0时
				- A1的松弛度 = 20 - 10 - 0 = 10ms
				- B1的松弛度 = 50 - 25 - 0 = 25ms
				- A1优先
		- 调度时机：进程到达或者有进程的松弛度为0（抢占）
	- 多处理机系统中的调度
		- 多处理机的类型
			- 紧密耦合
				- 通过**高速总线**或**高速交叉开关**来**实现多处理器间的互联**
				- 共享存储器系统和I/O设备，并要求将**主存**储器**划分**为**若干个**能独立访问的**存储器模块**，一边多个处理机能同时对主存进行访问。系统中的所有资源和进程，都由**操作系统**实施**统一**的控制和管理
			- 松散耦合
				- 通过**通道**或**通信线路**来实现**多台计算机**之间的互联
				- 每台计算机都**有自己的存储器**和	i/O设备，并配置了	OS来管理本地资源和在本地运行的进程
				- 每一台计算机都能**独立地工作**，必要时可通过通信线路**与其他计算机交换信息**，以**协调他们之间的工作**
			- 对称多处理器系统
				- 在系统中所包含的各**处理器**单元，在**功能和结构上是相同**的。
			- 非对称处理器系统
				- 在系统中有**多种类型**的**处理单元**，他们的功能和结构各不相同，其中只有**一个主处理器**，有**多个从处理器**
	- 进程分配方式
		- 对称MPS系统中的进程分配方式
			- 所有处理器都是相同的，把所有处理器作为一个**处理器池**，有调度程序或基于处理器请求，将池中的**任意一个处理器分配给任意一个进程**
				- 静态分配方式
					- 进程从开始执行到完成被**固定地**分配到一个处理器上。必须为**每个处理器单独安排一个就绪队列**
					- 优缺点：进程调度开销较小，但各个处理器忙闲不均
				- 动态分配方式
					- 在系统设置中设置**公共就绪队列**，分配时可将进程分配到任意一个处理器上
					- 优缺点：消除了各处理器忙闲不均的现象，但对于松耦合系统，在一个处理器A上的进程转至B上运行时，必须将A处理器所保存的信息传给B
		- 非对称MPS系统中的进程分配方式
			- 其OS大多采用**主-从式**OS，即OS的**核心**部分**驻留**在一台**主机**上，而从机上只是用户程序，**进程调度只有主机执行**
			- 每当**从机空闲**时，便向主机发送一**索求进程**的信号，然后便等待主机为它分配进程
			- 在**主机**中保持有一个**就绪队列**，只要就绪队列不空，主机便从其队首摘下一进程分配给请求的从机
			- 从机接收到分配的进程后便运行该进程，该进程结束后从机又向主机发送请求
	- 进程（线程）调度方式
		- 自调度方式
			- 自调度方式是一种最简单的调度范式，直接由**单处理机**环境下的**调度方式演变而来**
			- 在系统中设置有一个**公共的**进程或线程**就绪队列**，所有的**处理器**在**空闲**时都可**自己到该队列中取得一进程或线程**来执行
			- 在自调度方式中，可采用在单处理机环境下所调用的调度算法。如先来先服务FCFS算法，最高优先权算法FPF等。研究表明在多处理机系统中，FCFS,FPF和抢占式FPF三种算法，FCFS由于其他两种算法，且其算法简单，开销小
			- 优点：
				- 系统中的**公共就绪队列**可**按照单处理机**系统中采用的各种方式加以**组织**，其调度算法也可沿用单处理机系统所用的算法，很容易将单处理机环境下的调度机制**移植**到多处理机系统中，故它仍然是当前多处理机系统中较常用的调度方式
				- 只要系统中有任务，或者说只要公共就绪队列不空，就**不会出现处理及空闲的状况**，也不会发生处理器忙闲不均的现象，因而有利于提高处理器的利用率
			- 缺点
				- 瓶颈问题:整个系统中只设一个就绪队列，各处理器必须**互斥的访问**
				- 低效性:当线程**阻塞后重新就绪**时，只能进入这个就绪队列，但却单独，要重新拷贝数据
				- 线程切换频繁：相互合作的线程很嫩同时运行
		- 成组调度方式
			- 将一个进程中的**一组线程分配到一组处理器**上去执行
			- 在成组调度时，如何为应用程序分配处理器时间
				- **面向所有应用程序**平均分配处理器时间
				- **面向所有线程**平均分配处理器时间
				- ![Eb7GEF.png](https://s2.ax1x.com/2019/05/16/Eb7GEF.png)
		- 专用处理器分配
			- 在**一个应用程序**执行期间，专门为该应用程序分配**一组处理器，每个线程一个**，这组处理器为该程序**专用**，直至完成
			- 这种方式的主要理由如下
				- 在含有几百或几个处理器的系统中，每个处理器的投资只占很小一部分，**性能的重要性要高于对处理器利用率**的考虑
				- 每个进程或线程专用一个处理器可以完全**避免进程或线程的切换**
## 死锁的基本概念
- 死锁：指多个进程因竞争共享资源而造成的一种僵局。若无外力作用，这些程序永远不能前进
- 死锁问题
	- 一组阻塞的进程集合，该集合中每一个进程都拥有一定的系统资源并且在等待集合中其他进程所拥有的资源
	- 过桥问题
		- ![EbHnaD.png](https://s2.ax1x.com/2019/05/16/EbHnaD.png)
		- 汽车只能在右行车道上行驶
		- 桥上的每个容车部位可以看作一个资源
		- 如果发生思索，成功解决死锁的方法是要求一辆汽车推出桥面（剥夺资源且退后rollback）
		- 如果发生死锁，某些汽车可能必须后退
		- 饿死由可能发生
- 产生死锁的原因
	- 竞争资源
	- 顺序不当
- 产生死锁的必要条件
	- 只有四个条件都满足时，才会出现死锁。
		- 互斥：任意时刻只允许一个进程使用资源
		- 请求和保持：进程在请求其余资源时，不主动释放已经占用的资源
		- 不剥夺：进程已经占用的资源，不会被强制剥夺
		- 环路等待：存在一个处于等待状态的进程集合{p0,p1,...,pn}，其中进程p0正在等待目前p1所拥有的资源，p1等待p2的。。。。。pn等待p0的
- 处理死锁的方法
	- 预防死锁——加限制条件
	- 避免死锁——分配资源时加以限制
	- 检测死锁
	- 解除死锁
## 死锁的预防和避免
- 预防死锁
	- 预防是采用某种策略，限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的必要条件
	- 破坏死锁的四个必要条件之一即可预防死锁
	- 使用限制紫泉请求的方法可以预防死锁
		- 互斥
			- 可共享的资源不需要互斥使用，对不可共享的资源（独占的）必须实现独占使用
		- 占有并等待
			- 必须确保一个进程请求的资源时它不拥有任何其他系统资源
			- 要求进程在开始执行前，操作系统一次性分配该进程所需所有资源，火鹤只允许在进程不拥有任何资源的情况下请求资源
			- 较低的资源利用率而且有可能产生饿死现象（同时申请多个常用资源的情况）
		- 不可剥夺
			- 如果一个进程拥有某些资源并申请其他资源，但申请的资源一时得不到满足，那么这个进程所应拥有的资源就被剥夺
			- 被剥夺的资源名称加到这个进程请求资源的列表上
			- 进程进程获得了原有资源和新申请的资源时，进程才可以重新执行
			- 这种方法只可用于其状态可保存和恢复的CPU资源，如CPU内部的寄存器以及内存单元
		- 循环等待	
			- 利用对所有的资源类型排序，且要求进程按照增量的顺序来申请资源
- 避免死锁
	- 需要进程向操作系统提供使用资源的**附加信息**
	- 最为简单也是最有效的方法时进程必须**事先声明**他可能需要的各类资源实例的最大需求数量
	- 避免死锁算法**动态检查资源分配状态**以确保不能出现循环等待状态
	- 资源分配状态可以通过目前的**资源可用数量，已分配资源数量和进程最大请求数量**来表述
- 系统的安全状态
	- 安全状态
		- 是指系统能按某种顺序来为每个进程分配其所需的资源，直至最大需求，使每个进程都可顺利完成
	- 安全序列
		- 一个进程序列{P1，…，Pn}是安全的，如果对于每一个进程Pi(1≤i≤n），它以后需要的资源量不超过系统当前剩余资源量与所有进程Pj (j < i )当前占有资源量之和，系统处于安全状态。
		- 举例
			- ![EqQMDA.png](https://s2.ax1x.com/2019/05/17/EqQMDA.png)
- 利用银行家算法避免死锁
	- 避免死锁：在分配资源是判断是否会出现死锁，如不会死锁，则分配资源
	- 银行家算法问题
		- 一个进行家把他的固定资金贷给若干客户，只要不出现一个顾客借走所有的资金后还不够，银行家的资金应该是安全的。银行家需要一个算法保证借出去的资金有限时间内可收回
		- 假定顾客分成若干次进行，并在第一次借款时能说明做大借款额
		- 具体算法
			- 顾客的借款操作依次顺序进行，直到全部操作完成
			- 银行家对当前顾客的借款操作进行判断，以确定其安全性
			- 安全，则贷款，否则，暂不贷款
	- 银行家算法的特点
		- 允许互斥，部分分配和不可抢占，可提高资源利用率
		- 要求事先说明最大资源要求，在现实中很困难
## 死锁的检测和解除
- 保存资源的请求和分配信息，利用某种算法对这些信息加以检查，以判断是否存在死锁。死锁检测算法主要是检查是否有循环等待
