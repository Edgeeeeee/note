# 存储器管理
- 存储器的功能：保存数据
	- 存储器的发展方向是高速，大容量，小体积
- 存储组织的功能
	- 存储技术和CPU寻址技术许可的范围内组织合理的存储结构。其依据是访问速度匹配关系，容量要求和价格
## 存储器管理
- 存储器的物理组织，多级存储器
	- 存储组织是指在存储技术和CPU寻址技术许可的范围内组织合理的存储结构
	- 微机中的存储层次组织
	- ![Eqtj4s.png](https://s2.ax1x.com/2019/05/17/Eqtj4s.png)
- 存储管理的功能
	- 存储分配和回收
	- 地址变换
	- 存储共享和保护
	- 存储器扩充
## 程序的装入和链接
- 步骤：编译，链接，装入
- 可执行文件的建立：源程序编译成为目标程序模块，多个目标文件模块或程序库链接成为可执行文件，装入成为进程
- 程序的装入：
	- 重定位：在可执行文件装入时需要解决可执行文件中地址和内存地址的对应，由曹祖系统中的装入程序loader来完成
	- 三种方式
		- 绝对装入
			- 在可执行文件中记录内存地址，装入时直接定位在上述内存地址
			- **事先确定**了**程序将驻留**在内存的什么**位置**。即在内存中的**绝对地址**
			- 装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需要对程序和数据的地址进行修改
			- 程序中所使用的绝对地址即可在编译或汇编时给出，也可由程序员直接赋予
			- 优点：转入过程简单
			- 缺点：
				- 过于依赖硬件结构，不适于多道程序系统
				- 绝对装入方式只能将目标模块装入到内存中事先指定的位置
				- 多道程序下，不可能预知目标在内存中的地址，因此绝对装入方式不适合在多道环境下使用
		- 可重定位装入（静态）
			- 程序中**目标模块的地址通常从0开始**其他地址都是相对于0计算——相对地址
			- 把再装入时**对目标程序中指令和数据的地址修改过程**称为重定位，又因为**地址变换通常是在装入时一次完成的**以后不在改变，故称为**静态重定位**
			- 在装入前链接所假设的程序地址与此时装入的实际地址不一致
			- 在可执行文件中，列出各个需要重定位的地址单元和相对地址值，装入时再根据所定位的内存地址区修改每个重定位地址项，添加相应偏移量
			- ![EqUjlq.png](https://s2.ax1x.com/2019/05/17/EqUjlq.png)
			- 优点：不需硬件支持，可以装入有限多道程序
			- 缺点：	
				- 一个城西通常需要占用连续的内存空间，程序装入后内存不能移动
				- 不宜实现共享
				- **不断地分配和回收，造成了内存中小空闲块很多，总空闲空间量够，但分配不了**
		- 动态运行期装入（动态重定位）
			- 可重定位方式不允许程序运行时**在内存中移动位置**
			- 动态运行时的装入程序，时再把装入模块装入内存后，并不立即把装入的模块中的相对地址转换为绝对地址，而是把这种**地址转换推迟到程序真正要执行时才进行**因此**装入内存后的所有地址都仍是相对地址**
			- 在可执行文件中居鲁虚拟内存地址，装入和执行时通过硬件地址变换机构，完成虚拟地址到实际内存地址的变换
			- ![Eqaog1.png](https://s2.ax1x.com/2019/05/17/Eqaog1.png)
			- 优点：
				- OS可以将一个程序分散存放于不连续的内存空间，可移动程序，有利于实现共享
				- 能够支持程序执行中产生的地址引用，如指针变量
			- 缺点：需要硬件支持（通常是CPU），OS实现复杂——是虚拟存储的基础
- 逻辑地址空间和物理地址空间
	- 将**逻辑地址空间与物理地址空间相分离**，是内存管理的核心
		- 逻辑地址——由CPU（指令译码器）生成的地址，（程序员使用的地址或指令的地址码部分最终确定的地址），也称虚地址
		- 物理地址：内存单元的地址
	- 如果地址绑定工作在编译阶段或加载阶段完成，那么逻辑地址与物理地址是相同的；如果地址绑定工作在执行阶段完成，那么逻辑地址（虚地址）与物理地址是不同的
- 存储管理单元MMU
	- MMU是一个硬件装置，他将虚地址映射成物理地址（MMU目前作为CPU硬件的一个功能单元存在于CPU中）
	- 在使用MMU的方案中，用户进程每次产生的地址再送到存储器之前，都要加上存放在重定位寄存器（基地址寄存器）中的值（基地址），从而形成物理地址
	- 用户程序中出现的地址都是逻辑地址；用户程序不可能直到真实的物理地址是什么
- 程序的链接
	- 链接是指多个目标模块在执行时的地址空间分配和相互引用
	- 分类
		- ![EqwDO0.png](https://s2.ax1x.com/2019/05/17/EqwDO0.png)
	- 静态链接
		- 静态链接是生成可执行文件时进行的。在目标模块中记录符号地址，而在可执行文件中改写为指令直接使用的数字地址
		- 在程序**运行前**，先将个目标模块及所需的库函数连接成一个完成的装配模块，以后不在拆开
		- 再将这几个目标模块装配成一个装入模块时必须要解决以下两个问题
			- 对相对地址进行修改
			- 变换外部调用符号
		- 有冗余
	- 动态链接
		- 再装入或运行时进行连接。通常被连接的共享代码称为**动态链接库DLL**或共享库
		- 装入时动态链接
			- 将用户的源程序编译后所得的一组目标模块在装入内存时采用边装入边链接的方式
			- 便于修改和更新，便于实现对目标模块的共享
		- 运行时动态链接
			- 应用程序每次运行的模块可能不相同，运行时动态连接方式将对某些模块的链接推迟到执行时才进行，及即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存，把它链接到调用者模块上
			- 凡在执行过程中未被用到的莫表模块都不会被调入内存和被链接到装入模块上，这样不仅可**加快程序的装入**过程，而且**可节省大量的内存空间**
			- 优点：
				- 共享：多个进程可以公用一个DLL，节省内存，减少文件交换
				- 部分装入：一个进程可以将多种操作分散在不同的DLL中实现，而只将当前操作相应的DLL装入内存。
				- 便于局部代码修改：即便于代码升级和代码重用；只要函数的接口参数（输入和输出）不变，则修改函数机器DLL无需对可执行文件重新编译或链接
				- 便于运行环境的适应：调用不同的DLL就可以适应多种使用环境和提供环境不同的功能。如不同的显卡只需厂商为其提供特定的DLL，而OS和应用程序不必修改
			- 缺点
				- 链接开销：增加了程序执行时的链接开销
				- 管理开销：程序由多个文件组成，增加管理复杂度
- 覆盖
	- 任何时候在内存中仅保留需要的指令和数据，将程序的必要部分的代码和数据常驻内存，可选部分平时放在外存中，需要时装入
	- 当进程的大小比分配给他的内存地址空间大时，可以考虑使用覆盖技术
	- 谁覆盖谁由用户实现，无需操作系统的支持，程序设计时程序员需要精心的考虑编写支持覆盖的程序结构
- 交换
	- 一个进程可以从内存临时交换到后备存储器上存放，其后需要执行时再将其调入内存中
	- 后备存储器——快速的磁盘，需要有足够的存储空间来存放用户在内存的存储映像，同时必须提供对这些内存映像的直接访问。
## 连续分配方式
- 连续分配是指为一个用户程序分配一个连续的内存空间
- 因为程序的执行时根据指令计数器顺序执行，在执行本指令时，他已是下条指令的位置，跳转指令会自动置为跳转的目标地址，所以决定了程序必须占有连续的一段存储区

- **连续内存分配法**
	- 内存分为两个区域：系统区，用户区。应用程序装入到用户区，可使用用户区全部空间
	- 最简单，适用于单用户，单任务的OS。
	- ![EqyB6J.png](https://s2.ax1x.com/2019/05/17/EqyB6J.png)
	- 优点：易于管理
	- 缺点：对要求内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存

- **固定分区分配**
	- 把内存划分为若干个固定大小的连续分区
	- 分区大小相等：只适合于多个相同程序的并发执行
	- 分区大小不等：多个小分区，适量的中等分区，少量的大分区。
	- [![Eq6FhT.png](https://s2.ax1x.com/2019/05/17/Eq6FhT.png)](https://imgchr.com/i/Eq6FhT)
	- 优点：易于实现，开销小
	- 缺点：内碎片造成浪费，分区总数固定，限制了并发程序执行的程序数目
- **动态分区管理（概念）**
	- 根据进程的实际需要，动态的为之分配内存空间
	- 分配中的数据结构
		- **空闲分区表**：记录每个空闲分区的清空昂、
		- **空闲分区链**：实现对空闲分区的分配和链接
		- ![Eq6mu9.png](https://s2.ax1x.com/2019/05/17/Eq6mu9.png)
		- 回收与合并（四种情况）
			- ![Eq6l4K.png](https://s2.ax1x.com/2019/05/17/Eq6l4K.png)
			- 进程运行结束释放内存时系统根据回收区的首地址把他插入到空闲链表中
- 碎片
	- 碎片：不可利用的孔
	- 外碎片：目前所有孔的空间之和可以满足请求，但是这些孔之间没有毗邻
	- 内碎片：分配给进程的孔比进程的请求略微大一些，多出的部分在分区内，但是不能被利用
- **分区分配算法**
	- 分区分配算法
		- 寻找某个空闲分区，其大小需大于或等于进程的需求。若是大于要求，则将该分区分割成两个分区。其中一个分区为要求的大小，标记为占用，另一个余下的分区标记为空闲。分区的先后次序通常是从内存低端到高端
		- 分区释放算法：需要将相邻的空闲分区合并成一个空闲分区
	- **首次适应法**
		- 按分区的先后次序，从头查找，找到符合要求的第一个分区
		- 该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端但随着低分区不断划分而产生较多小分区，每次分配时查找时间开销会增大。
	- **下次适应法（循环首次适应）**
		- 按分区的先后次序，从上次分配的分区起查找（到最后时再回到开头），找到符合要求的第一个分区
		- 该算法的分配和释放的时间性能较好，使空闲分区分布的更均匀，但较大的空闲分区不宜保留
	- **最佳适应法**
		- 找到其大小与要求相差最小的空闲分区
		- 从个别来看，外碎片较小，但从整体来看，会形成较多外碎片。教导的空闲分区可以被保留
	- **最坏适应法**
		- 基本不留下小空闲分区，但较大的空闲分区不被保留
	- **首次适应被认为最好，最快，其次是循环，最佳，最坏（每次分配后剩下小碎片，难再分，不得不经常压缩内存，反而浪费CPU)**
	- 分区式存储管理的优缺点
		- 优点：
			- 便于动态申请内存
			- 便于共享内存
			- 便于动态链接
		- 缺点
			- 碎片问题，要求连续的内存空间，内存利用率不高，受实际内存容量限制
			- 解决
				- 紧凑技术：通过在内存移动程序，将所有小的空闲区域合并为一的空闲区域
				- 紧缩的前提是要有动态重定位机构来支持，即在指令执行时才确定有关物理地址
				- I/O问题：当进程等待I/O时必须锁定任务，不能移动；I/O执行所涉及的数据需要放到OS设定的缓冲区中
				- 问题：开销大，移动时机
## 分页存储管理方式
- 在前面的几种存储管理方法中，进程使用的地址都是物理地址；进一步的存储管理方法通过引入进程的逻辑地址，把进程地址空间与实际的存储位置分离，从而增加存储管理的灵活性；对程序的物理地址非连续分配
- [![EqW3XF.md.png](https://s2.ax1x.com/2019/05/17/EqW3XF.md.png)](https://imgchr.com/i/EqW3XF)
- 分页存储管理的基本方法
	- 页面和物理块
		- 将程序的逻辑地址空间和物理内存划分为 固定大小的也（Page）或页框，程序加载时，分配其所需的全部页，这些页不必连续。需要CPU的支持
		- ![EqjGu9.png](https://s2.ax1x.com/2019/05/17/EqjGu9.png)
		- 例如，页面大小1kb，逻辑地址为2170.p = int（2170/1024） = 2，d = 2170 mod 1024 = 122
	- 页表
		- 进程页表：逻辑页号（本进程的地址空间） -> 物理页号（实际内存空间）；每个进程有一个页表，描述该进程占用的物理页面及逻辑排列顺序；
		- 物理页面表：整个系统有一个物理页面表，描述物理内存空间的分配和使用情况。数据结构：位示图，空闲页面链表；
		- 请求表：整个系统有一个请求表，描述系统内部各个进程页表的位置和大小，用于地址转换，也可结合到各进程的PCB里。
		- [![Eqvwaq.png](https://s2.ax1x.com/2019/05/17/Eqvwaq.png)](https://imgchr.com/i/Eqvwaq)
	- 页面大小的选择
		- 通常是几kb到几十kb
		- 较小的页面：减小内碎片，但加大页表的长度，从而形成新的开销，并增加换入换出的开销
		- 较大的页面：减小页表的长度，加大内碎片；管理开销小，交换时对外存I/O效率较高
	- 优缺点
		- 优点
			- 没有外碎片，每个内存碎片不超过页大小
			- 一个程序不必连续存放。便于改变程序占用空间的大小（主要指随着程序运行而动态生成的数据增多，要求地址空间相应增长，通常由系统调用完成而不是操作系统自动完成）
		- 缺点：程序全部装入内存

	- 地址变换机构
		- 逻辑地址 -> 物理地址
		- 逻辑页号 -> 物理块号
		- 基本地址变换机构
			- 指令给出的地址分为两部分：逻辑页号，页内偏移地址，通过查进程页表得到物理页号，从而形成物理地址
			- ![ELaaoF.png](https://s2.ax1x.com/2019/05/17/ELaaoF.png)
			- ![ELd5AU.png](https://s2.ax1x.com/2019/05/17/ELd5AU.png)
			- ![ELdzND.png](https://s2.ax1x.com/2019/05/17/ELdzND.png)
			- ![ELwkut.png](https://s2.ax1x.com/2019/05/17/ELwkut.png)
			- ![ELwZE8.png](https://s2.ax1x.com/2019/05/17/ELwZE8.png)
	- 页表的实现
		- 页表通常被放在主存中
		- 页表基址寄存器用来指示页表在内存的起始位置
		- 页表长度寄存器，用来指示页表的大小
		- 每次CPU内存中的指令或数据的访问都需要访问两次内存，第一次访问页表，的二次访问指令或数据
		- 为了解决上述问题，通常在CPU中设置一个容量不大的专门用于快速查找的Cache
	- 具有块表的地址变换机构
		- 为了缩短查找时间，可以将页表从内存装入到关联存储器，按内容查找，即逻辑页号 -> 物理页号
		- ![图片1.png](https://i.loli.net/2019/05/17/5cdea5cceb8bc57959.png)
## 分段存储管理
- 分页管理的方法，提高内存的利用率，对程序员是透明的；分段管理方法，满足了程序员再编程和使用上的要求，适应软件工程开发上的要求
- 将程序的地址空间划分为若干个段，程序加载时，分配其所需的所有段，这些段不必连续；物理内存的管理采用动态分区，需要CPU的硬件支持
- 分段管理的主要目的
	- 方便编程、
		- 通常，一个作业是由若干个自然段组成。因而，用户希望能把自己的作业按照逻辑关系划分为若干个段；每个段都有自己的名字和长度；要访问的逻辑地址是由段名（段号）和段内偏移量决定；每个段都从0开始编址。这样，用户程序在执行过程中可用段名和段内地址进行访问
	- 信息共享
		- 通常，在实现程序和数据的共享时，都是以信息的逻辑单位为基础的。为了实现共享，也希望存储管理能与用户程序分段的组织方式相适应
	- 信息保护
		- 在多道程序环境下，为了防止其他程序对某种程序在内存中的数据有意无意的破坏，必须采用保护措施，对内存中的信息保护，同样实对信息的逻辑单位进行保护。因此，采用分段的组织和管理方式，对于实现保护功能，将是有效和方便的
	- 动态增长
		- 在实际使用中，往往有些段，特别是数据段，会不断地增长，而事先又无法确切的直到数据段会增长到多大。这种动态增长的情况是其他几种存储管理方式都难于应付的；而分段存储管理方式能很好地解决这一问题
	- 动态链接
		- 通常，用户源程序晋国编译所形成的若干个目标程序，还需在经过链接以形成可执行程序后，方能执行，进行的链接称为动态链接。动态链接是指在作业运行之前，并不把几个目标程序段链接起来
- 分段系统的基本原理
	- 分段
		- ![ELDUPS.png](https://s2.ax1x.com/2019/05/17/ELDUPS.png)
	- 段表：由段基址和段长组成
		- ![ELDa8g.png](https://s2.ax1x.com/2019/05/17/ELDa8g.png)
	- 地址变换机构
		- ![ELD6aV.png](https://s2.ax1x.com/2019/05/17/ELD6aV.png)
- 分页和分段的主要区别
	- 页是物理单位，而段是逻辑单位。分页是出于系统管理的需要，分段式处于用户应用的需要。因此一条指令或一个操作数可能会蛞蝓两个页的分界处，而不会跨越两个段的分界处
	- 页大小是系统固定的，而段大小则通常是不固定的
	- 逻辑地址表示：分页是一维的，各个模块在链接时必须组织成同一个地址空间；而分段是二维的，各个模块在链接时可以每个段组织成一个地址空间。（在分页中，只需要一个标识符，即可表示一个地址，是一维的。分段时，既要给出段名，有需要给出段内地址，是二维的。）
	- 同城段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度
	- ![ELrnZq.png](https://s2.ax1x.com/2019/05/17/ELrnZq.png)
- 段页式存储管理方式
	- 结合分段和分页的优点
		- [![ELr3z4.png](https://s2.ax1x.com/2019/05/17/ELr3z4.png)](https://imgchr.com/i/ELr3z4)
		- ![ELrwFK.png](https://s2.ax1x.com/2019/05/17/ELrwFK.png)
	- 地址变换过程
		- ![ELr2wt.png](https://s2.ax1x.com/2019/05/17/ELr2wt.png)
## 虚拟存储器
- 前面所介绍的各种存储器管理方式，其共同的特点就是要求将一个作业全部装入内存才能运行，因而难以适应
	- 作业的尺寸大于实际内存的容量
	- 有大量的作业等待运行，但实际内存容量不足以将其全部装入，因此必须找到一种合适的方法解决此类问题，从而引入了**虚拟存储器**
- 虚拟存储器的基本概念
	- 交换技术与覆盖技术
		- 是在多道环境下扩充内存的方法，用以解决在**较小的存储空间中运行较大程序**时的矛盾
		- **覆盖技术**主要是在早期的操作系统中
		- **交换技术**被广泛用于小型分时系统中，交换技术的发展导致了虚存储技术的出现
		- 交换与覆盖的异同点
			- 共同点：进程的程序和数据主要放在外存，**当前的需要执行的部分**放在内存，内存外存之间进行信息交换
			- 不同点：控制交换方式
	- 覆盖技术
		- 把程序划分为若干个功能上相对独立的程序段，按照其自身的逻辑结构将那些**不会同时执行的**程序段**共享同一块内存**区域
		- 程序段先保存在磁盘上，当有关程序段的前一部分执行结束，把后续程序段调入内存，**覆盖前面的程序段**（内存“扩大”）
		- 覆盖：一个作业若干个程序段，或几个作业的某些部分**共享**某一个存储空间
		- 一般要求作业各模块之间有明确的调用结构，**程序员要向系统指明覆盖结构**，然后由操作系统完成覆盖
		- 缺点
			- 对用户不透明，增加了用户的负担
			- 目前这一技术用于小型系统中的系统程序的内存管理上
	- 交换技术
		- 当内存空间紧张时，系统将内存中某些进程暂时移到外存，把外存中某系进程换进内存，占据前者所占用的区域，这种技术是进程在内存与外存之间的动态调度。多用于分时系统中。
		- 所谓对换是指把内存中暂时不能运行的进程或者暂时不用的程序和数据调出到外存上，以腾出足够的内存空间，再把已具备与性条件的进程或进程所需的程序和数据调入内存。对换是**提高内存利用率**的有效措施
		- 如果对换是以整个**进程**为单位，称为**整体对换**或**进程对换**
		- 如果对换是以**页**或**段**为单位进行的，则成为**页面对换**或**分段对换**，又统称为**部分对换**
		- 对换空间的管理
			- 外存中对换区主要存放从内存中换出的进程，对换空间管理的主要目标是**提高进程换入和换出的速度**
			- **对换区中空闲盘块的管理**：在系统中配置相应的数据结构，记录外存的使用情况。形式与内存在动态分区分配方式中所用数据结构相似，即用**空闲分区表或空闲分区链**。每个表中应该包含两项，**对换区的首地址**及其**大小**
			- 对换区的分配采用**连续分配方式**，分配算法可以是首次适应算法，循环首次适应算法或最佳适应算法
		- 进程的换出与换入
			- 进程的换出
				- 系统先**选择**处于**阻塞状态**且**优先级最低**的进程作为换出进程，然后启动盘块，将该进程的程序和数据传送到磁盘的**对换区**上。若传送未出现错误，便回收其所占用的内存空间，并对该进程的**进程控制块**做相应的修改
			- 进程的换入
				- 系统应该定时的查看所有进程的状态，从中找出**就绪状态**但已经换出的进程，将其中**换出时间最久**的进程作为换入进程，将之换入。
	- 覆盖与交换的比较
		- 与覆盖技术相比，交换技术不要求用户给出程序段之间的逻辑覆盖结构，
		- 交换发生在进程或作业之间，而覆盖发生在同一进程或作业内
		- 覆盖只能覆盖那些与覆盖段无关的程序段
- 虚拟存储器的引入
	- 实存：作业一次全部装入内存，作业不能大于内存的实际大小，大于采用覆盖技术
	- 程序的驻留性：阻塞时有在内存，交换技术，但装入内存的程序和数据不一定马上使用
	- 具体体现
		- 程序在执行时，大部分是顺序执行的指令，少部分是转移和过程调用指令
		- 过程调用的嵌套深度一般不超过5，因此执行的范围不超过这组嵌套的过程
		- 程序总存在相当多的循环结构，他们由少量指令组成，而被多次执行
		- 程序中存在先当读对一定数据结构的操作，如数组操作，往往局限在较小的范围内
	- 局部性原理
		- 指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域，可以表现为
			- 时间局部性：一条指令的一次执行和下次执行集中在一个较短的时间段内
			- 空间局部性：当前指令和邻近的几套指令，当前访问的数据和邻近的几个数据都集中在一个较小的区域内
	- 虚存的定义
		- 在一个操作系统下，如果不要求任意用户程序实际占用的物理地址空间，大于或等于用户程序的逻辑地址空间，而且这种功能的实现对用户是透明的，这称该操作系统实现了虚拟存储管理技术，显影的用户进程空间称为虚存空间或虚地址空间。其大小由指令的有效地址宽度决定。
		- 虚拟存储器是一种借助外村空间，从而允许一个进程在其运行过程中不分地装入内存的技术
	- 虚拟存储的基本原理
		- 在程序转入时，不需要捡起全部读入到内存，而只需将但钱需要执行的部分页或段读入到内存，就可以让程序开始执行
		- 在程序执行过程中，如果需要执行的指令或访问的数据尚未在内存，则由处理器通知操作系统将相应的 页或段调入内存
		- 另一方面，系统将内存中暂时不使用的页或段调出保存在外存上，从而为要求装入额程序腾出空间
	- 虚拟存储的优点
		- 可在较小的可用内存中执行较大的用户程序
		- 可在内存中容纳多程序并发执行
		- 不必影响变成时候的程序结构（预覆盖技术比较）
		- 提供给用户可用的虚拟内存空间通常大于物理内存
- 虚拟存储器的实现方式
	- 建立在离散分配存储管理方式的基础上
	- 请求分页系统
	- 请求分段系统
	- 段页式虚拟存储器
- 虚拟存储器的特征
	- 离散性，多次性，对换性，虚拟性
		- 物理内存分配的不连续，虚拟地址空间使用的不连续
		- 与交换比较：调入和调出是对部分虚拟地址空间进行
		- 通过物理内存和快速外存相结合，提供大范围虚拟地址空间
			- 范围大，但占用容量不超过物理内存和外存交换区容量之和
			- 占用容量包括：进程地址空间的各个段，操作系统代码
## 请求分页存储器管理机制
- 页表机制
	- 怎加换入换出所要求的必要信息
	- ![EOV3ZV.png](https://s2.ax1x.com/2019/05/18/EOV3ZV.png)
- 缺页中断机构
	- 由处理器地址变换机构产生缺页中断，然后调用操作系统提供中断处理
	- 缺页中断的特殊性
		- 缺页中断在指令执行期间产生和进行处理，而不是在一条指令执行完毕后。所缺的页面调入后，重新执行被中断的指令
		- 一条中断可能产生多次中断。如 swap a，b。而指令本身和两个操作数都阔约相邻外存页的分界处，则产生五次缺页中断
		- ![EOV6iD.png](https://s2.ax1x.com/2019/05/18/EOV6iD.png)
- 页面分配策略
	- 分配时机
		- 立即调页：在进程开始执行前分配与装入
		- 请求调页：只有在实际访问某页时才通过发生缺页中断处理程序分配
			- 容易实现
			- 对外存I/O次数多，开销较大，要求	I/O速度块
		- 预先调页：由操作系统根据一定算法，动态预测将来最近时间最可能要访问那些页，并在这些页实际访问之前预先调入
	- 调入来源
		- 文件区或交换区。通常交换区的效率比文件区的高
	- 页面分配数量
		- 最小物理块数：保证进程运行至少要分配的物理快数
	- 页面分配和置换策略
		- 固定分配局部置换
			- 给每个进程分配固定数目的页框，当发生缺页中断时，只考虑从该进程所属的页框中调出旧的页面，从而换入新的页面
		- 可变分配全局置换
			- 预分配给进程一定数目的页框，OS控制一定数量的空闲页框，进程执行过程中，发生缺页时，OS就分配给该进程一个空闲的页框，当空闲的页框用完时，OS可根据需要从任意的进程中调出一个页框
		- 可变分配局部置换
			- 与分配给进程一定数目的页框，OS控制一定数量的空闲页框，载金城的执行过程中，发生缺页时，首先考虑从该进程所属的页框中调出旧的页面，若发现该进程频繁发生缺页中断，这是可分配新的页框给该进程，统计缺页中断率系统会有开销
## 页面置换算法	
- 功能：需要调入页面时，选择内存中那个物理页面被置换
- 目标（出发点）：减低页面更换率，应把未来不再使用的或短期内较少使用的页面调换出去。通常只能在局部性原理指导下一句过去的统计数据进预测；相反会出现“抖动”
- 页面锁定：用于描述必须常驻内存的操作系统的关键部分或时间关键的应用进程

- **先来先服务（FIFO）**
	- 在内存中时间最长的页面被淘汰
- **最佳页面置换算法（OPT.Optimal）**
	- 选择置换“未来不再使用的”或“里当前最远位置上出现的”页面
	- 可以证明最最佳页面置换算法由最小的缺页率
- **最近最久未使用算法**
	- 利用“最近的过去”预测“最近的将来”，最久为用的予以淘汰
	- 选择内存中最久为使用的页面被置换，只是局部性原理的合理近似，性能接近最佳算法