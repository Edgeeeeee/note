# 进程管理
- 为了描述程序在并发执行时对系统资源的共享，我们需要一个描述程序执行时动态特征的概念，这就是**进程或线程**
## 进程的基本概念
- 程序的执行有两种方式：顺序执行和并发执行
	- **顺序执行的特征**
		- 顺序性：按照程序结构所制定的次序
		- 封闭性：独占全部资源，计算机的状态只由该程序的控制逻辑所决定，结果不受外界因素的影响
		- 可再现性：初始条件相同，则结果相同
- 前趋图
	- **是一个有向无循环图**，用于描述进程之间执行的前后关系
	- **直接前趋，直接后继，初始结点，终止结点**
	-  每一个结点有一个**权值**
	-  **前趋图中必须不存在循环**
- 并发执行
	- ![Eh46C4.png](https://s2.ax1x.com/2019/05/12/Eh46C4.png)
	- **并发执行的特征**：
		- 间断性：表现为走走停停，一个程序可能走到中途停下来，失去原有的时许关系
		- 失去封闭性：共享资源，受其他程序的控制逻辑影响，
		- 失去可在现性：外界环境在程序的两次执行期间发生变化
	- 程序并发执行的条件
		- 达到封闭性和可在现行
		- 并发执行失去封闭性的原因是共享资源的影响，去掉这种影响就行了
- 进程的描述
	- 定义
		- 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。他对应虚拟处理机，虚拟存储器和虚拟外设等资源的分配和回收
	- 进程与程序的区别
		- 进程时动态的，程序是静态的：程序是有序代码的集合；进程是程序的执行
		- 进程是暂时的，程序是永久的；进程是一个状态变化的过程，程序可以用具储存
		- 进程与程序的组成不同：进程的组成包括程序，数据和进程控制块
		- 进程与程序的对应关系：通过多次执行，一个程序可对应多个进程，通过调用关系，一个进程可包括多个程序
	- 进程的**特征与状态**
		- **动态性**：进程具有动态的地址空间，地址空间上包括
			- **代码**
			- **数据**
			- 系统**控制信息**
		- **独立性**：**各进程的地址空间相互独立**，除非采用进程间通信手段
		- **并发性**：多个**进程实体**同村于内存中，且能在同一段时间内同时运行；引入进程实体的目的就是并发执行
		- **异步性**：各进程按照各自独立的，不可预知的速度向前推进
		- **结构性**：**程序段，数据段，PCB**；程序文件中通常也包含了代码段和数据段，**进程的创建于撤销就是PCB的创建于撤销**
	- 概念
		- 进程是**程序**的**一次执行**
		- 进程是一个程序及其数据在处理及上**顺序执行**时所**发生的活动**
		- 进程时程序在一个数据集合上运行的过程，它是系统进行资源**分配和调度**的一个**独立单位**
		- 进程是进程实体的运行过程，是系统进行资源费配和调度的一个独立单位
	- 进程的基本状态
		- ![Ehopcj.png](https://s2.ax1x.com/2019/05/12/Ehopcj.png)
		- **就绪状态**：进程已经获得处理机外的所需资源，等待分配处理机资源，只要分配到处理机就可执行，在某一时刻可能有若干个进程处于此状态
		- **运行状态**：占用处理及资源运行；出于此运行状态的进程的数目小于等于CPU的数目
		- **阻塞状态**：由于进程等待某种条件，如I/O请求或进程同步等，在条件满足之前无法继续执行。
		- 增加创建与结束的状态
			- [![EhoUvd.png](https://s2.ax1x.com/2019/05/12/EhoUvd.png)](https://imgchr.com/i/EhoUvd)
		- 增加挂起状态
			- ![Ehos58.png](https://s2.ax1x.com/2019/05/12/Ehos58.png)
		- 一个挂起的进程等同于不存在主存的进程，它将不参与进程调度，知道他们被对换金主存。具有如下特征
			- 该进程不能被立即执行
			- 挂起进程可能会等待一个时间，但所等待的事件是独立于挂起条件的，事件结束并不能导致进程具备执行的条件
			- 进程进入挂起状态是由于操作系统，父进程或进程本身阻止它的运行
			- 结束进程挂起状态的命令只能通过操作系统或父进程发出
		- 引起进程挂起的原因是
			- 操作系统中进程均处于等待状态，处理器空闲，此时，需要把一些进程对换出去，以腾出足够的内存装入就绪进程运行
			- 进程竞争资源，导致系统资源不足，负荷过重，此时需要挂起部分进程以调整系统负荷
			- 把一些定期执行的进程对换出去以减轻负荷
			- 用户要求挂起自己的进程，以根据中间执行情况和中间结果进行调试，检修和改正
			- 父进程要求挂起自己的后代进程，以进行某些检查和改正
			- 当系统出现故障或某些功能遭到破坏时，需要挂起某些进程以排除故障
	- 进程控制块
		- 记录用于描述进程情况及控制进程运行的全部信息。通常常驻于由OS维护的用来记录进程相关信息的一块内存
			- 每个进程在OS中的登记表项，OS据此对进程进行控制和管理
			- 处于核心段，通常不能由应用程序自身的代码来直接访问，而是要通过系统调用。
		- 进程控制块中的信息
			- 进程描述信息：
				- 进程标识符
					- 内部标识符，唯一。通常是一个整数；在所有的操作系统中，都为每一个进程赋予一个唯一的数字标识符，它通常是一个进程的序号。设置内部标识符主要是为了系统方便调用
				- 进程名
					- 外部标识符，不唯一。通常基于可执行文件
				- 用户表示符
				- 进程组关系
					- 有创建者提供，通常是由字母，数字组成，往往是由用户在访问该进程时候使用
			- 处理机状态信息
				- 处理机现场
					- 当前状态
					- 优先级
					- 运行统计信息
					- 事件：阻塞原因等
					- 存放于**进程调度**和**进程对换**有关的信息，包括：
						- **进程状态**
						- **进程优先级**
						- **进程调度所需的其他信息**
						- **事件**
			- 流程控制信息：
				- 代码执行入口地址
				- 程序的外存地址
				- 进程间同步和通信
				- 资源占用信息：虚拟地址空间的现状，打开文件列表；
				- 链接指针
					- **程序和数据的地址**：是指进程的程序和数据和数据所在的**内存或外存首地址**，以便在调度改程序执行时，能从PCB中找到其程序和数据
					- **进程同步和通信机制**：指实现进程同步和进程通信时必须的机制
					- **占用资源清单**: 列出除了CPU以外的，进程所需的全部资源及已分配到该进程的资源的清单
					- **链接指针**：给出本进程PCB所在队列中下一个进程的PCB的首地址
					- **家族联系**：指明本进程与家族的关系，如他的子进程与父进程的标识
		- PCB的组织方式
			- 将处于同一状态的进程组织在一起
				- 链表：同一状态的进程PCB成一链表，多个状态对应对各不同的链表
				- 各状态的进程形成不同的链表：就绪链表，阻塞链表
				- 索引表：统一状态的进程归于一个index表，对应状态对应多个不同的index表
## 进程控制
- 术语：核心态（系统太，管态，特权态）和用户态（目态）
- 现代的计算机的程序状态字中都至少由一个位，其值位0或1.这样区分出两种状态。分别时核心态和用户态。机器的一部分指令只能在核心态下运行，这样的指令成为特权指令
- 核心态：可执行所有的机器指令。OS运行在核心态，可以访问所有资源
- 用户态：用户进程运行在用户态。无法直接访问硬件资源，不可直接访问受保护的OS代码，只可以访问OS指定的寄存器和存储区域及有关资源
- 操作系统内核
	- 程序模块的集合，这些模块通常为与硬件紧密相连的（中断处理，设备驱动程序）或执行频率较高的（处理机调度）程序模块。他们常驻内存，不会被交换出去
	- 功能
		- 支撑功能：中断处理，时钟管理，原语操作
		- 资源管理功能：进程管理，存储器管理，设备管理
- **微内核结构**
	- 也称客户/服务结构
	- **微内核**是一个小型的操作系统核心，只有**最基本的操作系统功能才能放在内核中**
	- [![E4mevF.md.png](https://s2.ax1x.com/2019/05/12/E4mevF.md.png)](https://imgchr.com/i/E4mevF)
	- 微内核结构用一个水平分层的结构代替了传统的纵向分层的结构。在微内核外部的操作系统部件被当作服务器进程的实现，他可以借助通过微内核传递信息来实现相互之间的交流
	- 微内核由两大部分组成
		- “微”内核
			- 负责处理客户和服务器之间的通信
		- 若干服务
			- 每个服务只处理操作系统的一个方面的工作，都在用户态下运行
	- 优点
		- 容易扩展内核
		- 容易移植（所有与具体及其特征有关的代码都隔离在微内核中，如要将操作系统移植到不同的硬件平台上，只需修改内核中极少代码即可）
		- 更可靠安全（只有很少代码运行在核心模式下）
- 原语
	- 由若干条指令构成的“原子操作”过程，作为一个整体而不可分割。要么全做，要么全不做。许多系统调用就是用原语
	- 注意：并不是所有系统调用都是原语
- 进程的创建
	- 进程图
		- 树状结构，表示父子进程关系
	- 引起创建进程的事件：**在多道程序环境中，要运行程序，必须为其创建进程**。
		- 用户登陆
			- 分时系统的用户在终端登陆后，如果使合法用户，系统为其创建一个进程，并插入**就绪队列**
		- 作业调度
			- 在批处理系统中，当作业调度程序调度到某作业时，该作业装入内存，为他分配资源并创建进程
		- 提供服务
			- 当运行中的用户进程提出某种请求后，系统将专门创建一个进程来提供服务
		- 应用请求
			- 由应用程序为自己创建进程，以便能并发执行，如输入，计算，输出程序
	- 进程的创建
		- **申请空白PCB**
			- 为新进程申请唯一的数字**标识符**，并从PCB集合中索取一个空白PCB
		- 为新进程**分配资源**
			- 为新进程的程序和数据**分配内存**。对如**批处理**型作业，可在用户题除创建进程时要求提供所需内存大小，对于**交互性**作业，可以有系统来分配一定的空间
		- **初始化进程控制块**
			- **初始化标识信息**：讲系统标识信息写入新PCB
			- **初始化处理机状态信息**：使**程序计数器**指向程序的入口地址，栈顶指针指向栈顶。
			- **初始化处理及控制信息**：将进程的状态设置为**就绪状态**或**静止就绪状态**
		- **将进程插入就绪队列**，如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列
	- 粗略步骤
		- 申请空白PCB
		- 为新进程分配资源
		- 初始化进程控制块
		- 将新进程插入就绪队列
	- 资源继承共享
		- 父子进程共享所有的资源
		- 子进程共享父进程资源的子集
		- 父进程和子进程之间不共享资源
	- 执行关系
		- 父进程和子进程并发执行
		- 父进程等待子进程执行结束
- 进程中止的事件
	- 正常结束
		- 应有一个通知OS进程已经完成运行的指令，
		- 如在批处理系统中，通常程序在最哦换牌一条**Halt指令**或**终止的系统调用**。当程序执行Halt指令时，将产生一个中断，通知OS本进程已经完成。
		- 在分时系统中用户可利用Logs off去表示进程运行完毕，此时同样产生一个中断，告知OS进程已经运行完毕
	- 异常结束：在进程运行期间，由于出现某些错误和系统故障而迫使进程中止
		- **保护错**：进程试图**访问一个不允许访问的资源或文件**，或者**以不适当的方式访问**，如改写只读文件
		- **非法指令**：程序试图去**执行一条不存在的指令**，出现该错误的原因可能是程序错误的转移到数据区，把数据当成了指令
		- **特权指令错**：用户进程试图去**执行一条只允许OS执行**的指令
		- **等待超时**：进程等待某事件的时间超过规定的最大值
		- **运行超时**：运行时间超过最大值
		- **算术运算错**：进程试图去**执行一个被禁止的运算**，如0做除数
		- **I/O故障**：这是指在I/O过程中发生了错误等
	- 外界干预
		- 外界干预并非指在本进程运行中出现了异常事件，而是进程外界的请求而中止运行
		- **操作员或系统干预**：由于某种原因，如死锁，由操作员或系统终止进程
		- **父进程请求**：由于父进程具有中止自己的任何子孙进程的权利，因而当父进程发出请求时，系统将中止进程
		- **父进程中止**：当父进程中止时，OS也将它的所有子孙进程中止
	- 进程中止过程
		- 回收资源，释放内外存空间，关闭所有打开的文件，释放当前的目录，释放共享内存段和各种锁定
- 进程的阻塞与唤醒
	- 引起阻塞和唤醒的事件
		- 请求系统服务
			- 如请求打印机时，若**已被**其他进程**占用**，此时只能**阻塞**，等其他进程**释放**后在蒋勤求进程**唤醒**
		- 启动某种操作
			- 当进程启动某种操作后，如果该进程**必须在该操作完成后才能继续执行**，组必须先使进程阻塞，以等待该操作完成。如启动I/O设备
		- 新数据尚未到达
			- 对徐相互合作的进程，如过一个进程需要另一个合作进程提供的数据，则在**数据到达之前只能阻塞**
		- 无新共作可做
			- 系统的一些特殊功能进程，在完成任务了以后，**等待新任务**到来。如系统的发送进程
	- 进程阻塞过程
		- 进程自身调用有阻塞原语，进入等待队列。进程的主动性行为
		- 引起处理机调度
	- 进程被唤醒的过程
		- 当被阻塞进程**所期待的事件出现**时，如I/O完成或所期待的数据已经到达。则由有关进程调用**唤醒原语wakeup（）**将等待该事件的进程唤醒
		- 唤醒原语执行的过程
			- 把被阻塞的进程从等待该事件的阻塞队列中移出
			- 将其PCB中的现行状态由**阻塞**改为**就绪**
			- 将该PCB插入到就绪队列中
- 进程的挂起与激活
	- 原因：当出现**引进进程挂起的事件时**，比如用于进程请求将自己挂起，或父进程请求将自己的某个子进程挂起，系统将利用挂起原语**suspend（）**将指定进程或处于阻塞状态的进程挂起
	- suspend()原语的执行过程
		- 得到挂起进程的内部标识符
		- 检查被挂起的进程的状态，若处于**活动就绪**状态，便将其改为**静止就绪**状态；对于**活动阻塞**状态的进程，则将之改为**静止阻塞**
		- 为了方便用户或父进程考察该进程的运行情况，而把该进程的PCB复制到某制定的内存区域
		- 若被挂起的进程正在执行，则转向调度程序重新调度
	- 方法
		- 调用相关原语
	- 进程的激活过程
		- 当发生激活进程的事件时，如父进程或用户进程请求激活指定进程如该进程驻留在外存而内存中由足够的空间时，则可将外存上处于静止就绪状态的进程换入内存。这是，系统将调用**激活原语active（）**将指定进程激活
		- achieve()原语的执行过程
			- 激活原语先将进程从外存**调入内存**，检查该进程的现行状态，若为**精致就绪**，则改为**活动就绪**；若为**静止阻塞**，则改为**活动阻塞**
			- 若采用抢占调度策略，则没当有**新进程（激活）进入就绪队列**时，应该**检查**是否要重新调度，即由调度程序将被激活的进程与当前进程进行优先级比较，如果被激活进程的优先级更低，就不必重新调度。否则，**立即剥夺**当前进程的运行，把处理机分配给刚被激活的进程
## 进程的同步与通信
- 进程同步的基本概念
	- 由于多进程在操作系统中的并发执行，诸进程之间存在相互制约关系，即互斥关系和同步关系
	- 进程互斥是由于共享资源所要求的排他性，进程间要相互竞争，以获得这些资源的使用权。
	- 进程同步是指多个进程中发生的事件存在某种时序关系，必须协同工作，相互配合，以共同完成一项任务
- 在多进程系统中，我们可以把进程的相互制约关系按感知成都分成下表所列的三种类型
	- [![EI3oD0.md.png](https://s2.ax1x.com/2019/05/14/EI3oD0.md.png)](https://imgchr.com/i/EI3oD0)
- 临界资源
	- 硬件或软件（如外设，共享代码段，共享数据结构），多个进程在对其进行访问时（关键是写入和修改），必须互斥的运行。（有些共享资源可以同时访问，如只读数据）
- **临界区**
	- 定义
		- 临界区：在每个进程中，访问临界资源的一段代码
		- 进入区：在进入临界区之前，检查可否进入临界区的一段代码。如果可以进入临界区，通常设置相应**正在访问临界区**标志
		- 退出去：用于将”正在访问临界区“标志清除
		- 剩余区：代码中的其余部分
	- 临界区准则
		- 每次至多一个进程处于临界区
		- 若有多个进程同时要求进入他们的临界区，应该在有有限的时间内让其中一个进入而不应相互阻塞
		- 进程在临界区逗留有限时间
	- 同步机制准则
		- 空闲则如：其他进程均不处于临界区
		- 忙则等待：已有进程处于其临界区
		- 有限等待：等待进入临界区的进程不能‘死等’
		- 让权等待：不能进入临界区的进程应释放CPU（如转换到阻塞状态）
	- 用软件方法解决进程互斥问题
		- 算法1：**单标志**
			- [![EIJtEV.png](https://s2.ax1x.com/2019/05/14/EIJtEV.png)](https://imgchr.com/i/EIJtEV)
			- 缺点：强制轮流进入临界区，没有考虑进程的实际需要。如意在城资源利用的不充分：在pi出让临界区之后，pj使用临界区之前。pi不可能再次使用临界区
		- 算法2：双标志，先检查
			- 设立一个标志数组flag[]：描述进程是否在临界区，初值均为false
			- 先检查，后修改：在进入区检查另一个进程是否在临界区，不在时候修改本进程在临界区的标志；
			- 在退出区修改本进程在临界区的标志
			- [![EIJvvj.png](https://s2.ax1x.com/2019/05/14/EIJvvj.png)](https://imgchr.com/i/EIJvvj)
			- 优点：不用交替进入，可连续使用
			- 缺点：可能同时进入临界区
				- 即在检查对方flag之后和切换自己flag之前有一段时间，结果检查都通过。这里的问题出在检查和修改操作不能连续进行
		- 算法3：双标志，后检查
			- [![EIYBi8.png](https://s2.ax1x.com/2019/05/14/EIYBi8.png)](https://imgchr.com/i/EIYBi8)
			- 缺点：两程序可能都进不了临界区
				- 即在切换自己flag和检查对方flag之间有一段时间，结果都切换flag，检查都不通过
		- 算法4 ：先修改，后检查，后修改者等待（正确的算法，结合算法1和算法3）
			- [![EItPOA.png](https://s2.ax1x.com/2019/05/14/EItPOA.png)](https://imgchr.com/i/EItPOA)
			- 在进入区先修改后检查，并检查先后
				- 检查对方flag，如不在临界区，则自己进入
				- 否则检查turn：turn保存的时较晚的一次赋值，则较晚的等待，较早的进入。
			- 实现了同步机制的前两条：空闲让进和忙则等待
	- 用硬件方法解决进程互斥问题
		- 优点
			- 适用于任意数目的进程，在单处理器或多处理器上
			- 简单，容易验证其正确性
			- 可以支持进程内存在多个临界区，只需要为每个临界区设置一个布尔变量
		- 缺点
			- 等待要消耗CPU时间，不能实现“让权等待”
			- 可能“饥饿”：从等待进程中随机选择一个进入临界区，有的进程可能一直选不上
			- 可能死锁
	- **信号量机制**
		- 前面的算法都存在问题，他们是平等进程间的一种协商机制，需要一个地位高于进程的管理者来解决共有资源的使用问题
		- OS可从进程管理者的角度来处理互斥的问题，信号量就是OS提供的管理共有资源的有效手段，信号量代表**可用资源实体的数量**
		- **整型信号量机制**
			- P,V操作，现又称为wait和signal
			-代码
			- 
			 	
				wait(int s)
				{
					// 这是两条语句
					while(s<=0);
					s--;
				}
				
				signal(int s)
				{
				s++;
				}

		- 利用信号量实现互斥
			- 为临界资源设置一个信号量mutex，其初值为1
			- 在每个进程中将临界区代码置于wait(mutex)和signal(mutex)原语之间
			- 必须成对使用wait和signal原语，遗漏wait原语则不能保证互斥访问，遗漏signal原语则不能在使用临界区资源后将其释放；wait，signal原语不能次序错误，重复或遗漏
		- 利用信号量来描述前趋关系
			- [![EIdWPP.png](https://s2.ax1x.com/2019/05/14/EIdWPP.png)](https://imgchr.com/i/EIdWPP)
		- **推论**
			- 若信号量s为正值，则该值等于在封锁进程之前对信号量s可实行的P操作数，亦等于s所代表的实际还可以使用的物理资源数
			- 若信号量S为负值，则其绝对值等于登记排列在该信号量s队列之中等待的进程个数，亦恰好等于对信号量s实施p操作而被封锁起来并进入信号量s队列的进程数
			- 通常，p操作意味着请求一个资源，v操作意味着一个释放资源。在一定条件下，p操作代表挂起进程操作，v操作代表唤醒被挂起进程的操作
## 经典的同步问题
- 生产者-消费者问题
	- 问题描述1
		- 若干进程通过有限的共享缓冲区交换数据。其中生产者进程不断写入，消费者进程不断读出；共享缓冲区共有N个；任何时刻都只能有一个进程可对共享缓冲区进行操作。
	- 私用信号量和公用信号量
		- 私用信号量：指只与制约进程和被制约进程有关的信号量
		- 共用信号量：指与一组并发进程有关的信号量
	- 采用信号量机制：
		- full是“满”数目，初值为0，empty是“空”数目，初值为N。实际上full和empty是同一个含义：full + empty = N（私用信号量）
		- mutex用于访问缓冲区时候的互斥，初值是1（共用信号量）
		- ![Eo4yxe.png](https://s2.ax1x.com/2019/05/14/Eo4yxe.png)
		- 每个进程中各个wait操作的次序是重要的；先检查资源数目，在检查是否互斥。否则可能死锁
	- 问题描述2(苹果橘子问题)
		- 桌上有一空盘，允许存放一只水果。爸爸可向盘中放水果，也可向盘中放橘子，儿子专等吃盘中的苹果，女儿专等吃盘中的苹果。规定当盘子空时一次只能放一只水果
		- 应设置三个信号量，S,S0,Sa。信号量S表示盘子是否为空，初值为1.信号量S0表示是否由橘子，初值为0，讯号两Sa表示盘中是否有苹果，其初值为0;
		- ![ETGlT0.png](https://s2.ax1x.com/2019/05/15/ETGlT0.png)
		- ![ETG3kV.png](https://s2.ax1x.com/2019/05/15/ETG3kV.png)
- 读者-写者问题
	- 问题描述
		- 对共享资源的读写操作，任意时刻写者最多只允许一个，而读者可允许多个——读写互斥，写写互斥，读读允许
	- 采用信号量机制
		- wmutex表示允许写，初值为1
		- 公用信号量Rcount表示“正在读”的进程数，初值为0；Rmutex表示对Rcount的互斥操作，初值是1.
			- ![E75oYq.png](https://s2.ax1x.com/2019/05/15/E75oYq.png)
		- 修改上述的同步算法，使得它对写着优先，即一旦有写者到达，后续读者必须等待，而无论是否有读者在读文件
			- [![E75LXF.png](https://s2.ax1x.com/2019/05/15/E75LXF.png)](https://imgchr.com/i/E75LXF)
- 哲学家进餐问题
	- 问题描述
		- 五个哲学家围绕一张圆桌而坐，每个哲学家前面有一叠空心面，由于面很滑，所以要两把叉子才能抓住。相邻两个碟子之间有一把叉子
	- 制约关系
		- 哲学家只有两种活动，在感觉到饥饿时，分两次取左边的叉子和右边的叉子，不分次序，如果成功的得到两把叉子就吃饭，吃完继续思考
		- ![EHE0BD.png](https://s2.ax1x.com/2019/05/16/EHE0BD.png)
		- ![EHErAH.png](https://s2.ax1x.com/2019/05/16/EHErAH.png)
		- ![EHEhDS.png](https://s2.ax1x.com/2019/05/16/EHEhDS.png)
- 经典理发师问题
	- 假设后街有家理发店，店里有一个理发师，一把理发椅，和n把等候理发的顾客椅子
		- 如果没有顾客，则理发师则在椅子上看报纸
		- 当有一个顾客到达时，首先看理发师在干什么，如果在看报纸则告诉理发师理发，然后开始理发。如果理发师正在理发，则查看是否有空的椅子可坐，如果有，就坐下等待，如果没有，则离开
		- 理发师为一位顾客理完发后，查看是否有人等待，如果有则唤醒一位顾客理发，如果没有，则在理发椅上看报纸
		- 顾客不分优先级
	- ![EHVWGR.png](https://s2.ax1x.com/2019/05/16/EHVWGR.png)
## 管程机制
- 信号量机制的引入解决了进程同步的描述问题，但信号量的大量同步操作分散在各个进程中不便于管理，还有可能导致系统死锁
- 采用P-V同步机制编写并发程序，对于共享变量及信号量变量的操作将被分散于各个进程中
- 缺点
	- 易读性差，因为要了解对于一组共享变量及信号量的操作是否正确，则必须通读整个系统或者并发程序
	- 不利于修改和维护，程序的局部性很差，所以任意一组变量或一段代码的修改都可能影响全局
	- 正确性难以保证，因为操作系统或并发程序通常很大，要保证这样一个复杂的系统没有逻辑错误很困难
- 管程的基本概念
	- 定义
		- 一个管程定义了一个**数据结构**和能为并发进程所执行的**一组操作**这组操作能同步进程和改变进程中的数据
		- 管程由三部分组成
			- 局部于管程的**共享变量说明**
			- 对该数据结构操作的**一组过程**
			- 对于局部于管程的数据设置**初始值**的语句
		- 管程还必须有一个名字
	- 局部于管程的数据结构仅能被局部于管程的过程访问
	- 局部于管程的过程也仅能访问管程内的数据结构
	- 管程相当于围墙，把其共享变量和对它操作的过程围起来，而每次只允许一个进程进入，从而实现了互斥操作
	- 在实现一个管程时，必须考虑**互斥和同步**
	- ![EHmXW9.png](https://s2.ax1x.com/2019/05/16/EHmXW9.png)
## 进程通信
- 进程通信指进程间的信息交换
- 按通信内容可分为两种
	- 低级通信
		- 进程之间控制信息的交换称为低级通信。一般只传送一个和几个字节的信息，达到控制进程执行速度的作用（互斥和同步）。
		- 信号量机制作为同步工具是卓有成效的，但作为通讯工具则不够理想。效率低，通信对用户不透明
	- 高级通信
		- 用户可以直接利用操作系统所提供的一组命令，高效地传送大量数据的一种通信方式。可大大简化通信程序编制上的复杂性
	- 进程的同步与互斥是一种通讯方式，一进程可通过修改变量或信号量告知另一进程它是否可以继续执行下去，但P,V操作只能传递信号，信号本身不包含任何数据，而进程推进不当还导致程序容易死锁，因此称这些同步机构为低级通信机构
- **高级通信机制类型**
	- **共享存储器系统**
		- 相互通讯的进程通过共享**数据机构和存储区**进行通讯，可进一步分为
			- 基于共享数据结构的通讯方式；（低效，只适用于传送少量数据）、
			- 基于共享存储区的通讯方式。为了传送大量数据，在存储据中划出一块共享存储区，诸进程可通过对共享存储区进行读写数据实现通讯
	- **消息传递系统**、
		- 在消息传递系统中，进程间的数据交换是以消息（报文）为单位，程序员直接利用系统提供的一组通讯命令（原语）来实现通讯。因其实现的方法不同，可分为
			- **直接通信方式**（消息缓冲机制）
				- 发送进程直接将消息发送给接受进程，并将他挂载在接受进程的消息缓冲队列上，接受进程从消息缓冲队列中取得消息，所以称为**消息缓冲机制**
			- **间接通信方式**（信箱通信方式）
				- 发送进程将消息发送到某个中间实体中（一般为信箱），接收进程从中取得消息，所以称为信箱通信方式，相应地系统称为电子邮件系统
	- **管道通信系统**
- 邮箱通信（间接通信）
	- 信箱
		- 信箱是一种数据结构，逻辑上它分为两个部分：**信箱头**和由若干个格子组成的**信箱体**
		- 信箱中每个格子存放一封信，信箱指格子的数目和大小在创建信箱时确定。
	- 进程间的通信要满足以下条件
		- 发送进程发送消息时，邮箱中至少要有一个空格存放该消息
		- 接受进程在接受消息时，邮箱中至少要有一个消息存在
		- 信箱可有OS系统创建，也可以由用户创建，创建者是信箱的拥有着，据此可以把信箱分为私用信箱，公用信箱，共享信箱
		- 再利用信箱通信时，在发送进程和接收进程之间存在着四种关系
			- 一对一关系（专用通道）
			- 多对一关系（客户服务器交互）
			- 一对多关系（广播）
			- 多对多关系（公用信箱）
## 线程的基本概念
- 在OS中，进程的引入提高了计算机资源的利用率。但在进一步提高进程的并发性时，人们发现进程切换开销的比重越来越大，同时进程通信的效率也受到限制。引入线程的目的是用它来提高系统内程序的并发程度，提高系统效率，增大作业的吞吐量
- 线程的引入
	- 进程的两个基本属性
		- 资源分配单位
		- 处理机调度单位
	- 线程模型：进程作为资源分配单位，线程作为处理机调度单位
- 一个进程中可以由多个线程，由于统一进程内各线程都可以访问整个进程的所有资源，因此线程之间的通信比进程之间的通信要方便；而统一进程内的线程间切换也会由于许多上下文的相同而变化
- 同一进程内各线程的差异主要体现在现成的状态，寄存器上下文和堆栈等必不可少的线程环境上。这样，在OS中引入线程的概念就可以减少并发的事件和空间开销，容许通过在系统中建立更多地线程来提高并发行
- 线程的优点	
	- 线程的创建时间比进程短
	- 线程的终止时间比进程短
	- 同一进程内的线程切换时间比进程短
	- 由于统一进程内线程之间共享内存和文件资源，因此可进行直接通信，而不许掉通过OS的内核