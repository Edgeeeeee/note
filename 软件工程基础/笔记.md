# 第一章 软件的本质
- 软件的本质：程序+数据+文档
- 定义软件：
	- 指令的集合
	- 数据结构
	- 软件描述信息

# 第二章 软件工程
- 定义软件工程学科
	- 将系统化的，规范的，可量化的方法应用于软件的开发，运行和维护，即将工程化方法应用于软件；
	- 对上述方法的研究
- 软件过程
	- 活动
	- 动作
	- 任务
- 过程框架
	- 沟通，策划，建模，构建，部署
- 通用7原则
	- 存在价值：能为用户提供价值
	- 保持简洁：所有的设计都应该尽可能简洁，但不是过于简化
	- 保持愿景：清晰的愿景是软件项目成功的基础
	- 关注使用者：在需求说明，设计和实现过程中，牢记要让别人理解你所做的事情
	- 面向未来：永远不要把自己的设计局限于一隅
	- 提前计划复用：提前做好复用计划将降低开发费用，并增加可复用构件以及构件化系统的价值
	- 认真思考：在行动之前清晰定位，完整思考通常能产生更好的结果

# 第三章 通用过程模型
- 四种过程流模型，详细见简答第三章
	- 线性过程流
	- 迭代过程流
	- 演化过程流
	- 并行过程流

# 第四章 过程模型
- 瀑布模型（见简答）
	- 瀑布模型又称经典生命周期
- 增量过程模型（见简答）
	- 第一个增量往往是核心产品
- 原型开发
	- 很多时候，客户定义了软件的一些基本任务，但是没有详细定义功能和特性需求。另一种情况下，开发人员可能对算法的效率，操作系统的适用性和人机交互的形式等情况并没有把握。在这些情况或类似情况下，采用原型开发范型是最好的解决办法 
	- P33 4-4
- 螺旋模型
	- 螺旋模型是一种演进式软件过程模型。它结合了原型的迭代性质和瀑布模型的可控性和系统性特点
	- 螺旋模型是一种风险驱动型的过程模型生成器，对于软件集中的系统，他可以指导多个利益相关者的协同工作。他又两个显著的特点。一是采用循环的方式逐步加深系统定义和实现的深度。二是确定一系列里程碑作为支撑点，确保利益相关者认可是可行的且可令各方满意的系统解决方案。
	- 适合高风险。
- 统一过程的阶段
	- UP的起始阶段：包括客户沟通和策划活动。通过与利息相关者协作定义软件的业务需求，提出系统大致的架构，并定制开发计划以保证开发项目具有迭代和增量的特性。
	- 细化阶段：包括沟通和通用过程模型的建模活动。细化阶段扩展了初始阶段定义的用例，并扩展了体系结构以包括软件的五种视图——用例模型，需求模型，设计模型，实现模型和部署模型。
	- UP的构建阶段：与通用软件过程中的构建活动相同。构建阶段采用体系结构模型作为输入，开发或是获取软件构件，使得最终用户能够操作用例。
	- UP的转换阶段：包括通用构建活动的后期阶段以及通用部署活动的第一部分。软件被提交给用户进行Beta测试，用户反馈报告缺陷及必要的变更。
	- UP的生产阶段：与通用过程额部署活动一致。在该阶段对持续使用的软件进行监控，提供运行环境的支持，提交并评估运行报告缺陷及必要的变更。

# 第五章 敏捷开发
- 什么是敏捷
	- 敏捷团队是能够适当相应变更的灵活团队。变更就是软件开发本身，软件构建有变更，团队成员在变更，使用新技术会带来变更，各种变更都会对开发软件的产品带来以及项目本身造成影响。我们必须接收支持变更的思想，它应该根植于软件开发中的每一件事中。因为它是软件的心脏与灵魂。敏捷团队意识到软件是团队中所有人共同开发完成的，这些人的个人技能和合作能力是项目成功的关键所在。
- 敏捷12条原则
	- 我们最优先要做的是通过今早，持续交付有价值的软件来使客户满意。
	- 即使在开发的后期，也欢迎需求的变更。敏捷过程利用变更为客户创造竞争优势。
	- 经常交付可运行软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。
	- 在整个项目开发期间业务人员必须天天都在一起工作。
	- 围绕有积极性的个人构建项目。给他们提供所需的环境和支持，并且信任他们能够完成工作
	- 在团队内部，最富有效果和效率的信息传递方法是面对面的交谈
	- 可运行软件是进度的首要度量标准
	- 敏捷过程提倡可持续的开发速度，责任人，开发者和用户应该能够长期保持稳定的开发速度
	- 不断地关注优秀的技能和好的设计会增强敏捷能力
	- 简单——使不必要的工作最大化的艺术——是必要的
	- 最好的架构，需求和设计出自于自组织的团队
	- 每隔一定时间，软对会反省如何才能更有效地工作，并相应调整自己的行为 

# 第八章 需求建模，基于场景的方法
- 域分析
	- 软件域分析是指识别，分析和详细说明某个特定应用领域的共同需求，特别是那些在该应用领域内多个项目重复使用的......面向对象的域分析是在某个听定的应用领域内，根据通用的对象，类，部件和框架，识别，分析和详细说明公共的，可复用的能力
	- P98 8-2
- 需求建模的方法
	- 一种考虑和处理的需求建模方法称作结构化分析，其中处理过程将数据作为独立实体加以转换。
	- 需求建模的第二种方法称作面型对象的分析。
	- 需求模型的每个元素表示源自不同观点的问题。基于场景的元素表述用户如何与系统和实用软件时出现的特定活动序列进行交互。基于类的元素的内容包括：系统操作的对象，应用在这些对象间影响操作和对象间关系的操作，以及定义的类间发生的协作。行为元素描述了外部事件如何改变系统或驻留在系统里的类的状态。最后，面向流的元素表示信息转换的系统，描述了数据对象在流过各种系统功能时是如何转换的。
	- 需求模型导出每个建模元素的派生类。然而每个元素的特定内容可能因项目而异
	- P99 8-3
- 基于场景的建模
	- 活动图：P105 8-5
	- 用例图：P105 8-4
	- 泳道图：P106 8-6

# 第九章 需求建模：基于类的方法
- CRC 类—职责—协作者建模
	- CRC模型实际上是表示类的标准索引卡片的集合。这些卡片分三部分，顶部写类名，卡片主体左侧部分列出类的职责，右侧部分列出类的协作者。
	- 类的分类可以通过如下分类方式进行扩展：
		- 实体类：也称作模型或业务类，是从问题说明中直接提取出来的。这些类一般代表保存在数据库中和贯穿在应用程序中的事物
		- 边界类：用于创建用户可见的和在使用软件时交互的接口（如交互屏幕或打印的报表）实体类包含对用户来说很重要的信息，但是并不显示这些信息。边界类的职责是管理实体对象呈现给用户的方式。
		- 控制类：自始至终管理工作单元，也就是说，控制类可以管理
			- 实体类的创建或更新
			- 边界类从实体对象获取信息后的实例化
			- 对象集合间的复杂通信
			- 对象间或用户和应用系统间交换数据的确认
			- 通常知道设计开始时才开始考虑控制类
	- 职责
		- 智能系统应分布在所有类中以求最大程度地满足问题的需求
		- 每个指责的说明应尽可能具有普遍性
		- 信息和与之相关的行为应放在同一个类中
		- 某个事物的信息应局限于一个类中而不要分布在多个类中
		- 适合时，职责应由相关类共享
	- 类的关联和依赖
		- 在很多例子中，两个分析类以某种方式相互联系着。在uml中这些联系被称作关联
		- 关联可以更进一步指出多样性。

# 第十章 需求建模：行为和模式
- 状态转换图：
	- P123 10-1图
	- 状态转换图用来描述系统的状态，及引起系统状态转化的事件，来表示系统的行为
	- 状态转换图用来描述单程生命周期，也可以用来表示循环过程。
	- 单程生命周期：起点是实心圆，终点是同心圆，内圆为实心，初态只有一个，终态可以有很多。
	- 循环过程一般不考虑起点与终点
	- ![状态转换图](http://img-blog.csdn.net/20180314105513214)
- 顺序图：
	- 是一种强调对象间消息传递次序的交互图，又称为时序图或序列图。描述了自一个用例或操作的执行过程中对象如何通过消息互相交互，说明了消息如何在对象之间被发送和接收以及发送的顺序
	- 组成：
		- ![组成](http://images2015.cnblogs.com/blog/807775/201607/807775-20160723154036216-1758586530.png)
	- 一个复杂的顺序图可以划分为几个小块，每一个小块称为一个交互片段，由一个大方框包围
	- 消息
		- ![消息](https://images2015.cnblogs.com/blog/807775/201607/807775-20160723154234451-979219641.png)
		- 调用消息：在顺序图中有的消息对应于激活，表示他将会激活一个对象
		- 发送消息：如果消息没有对应激活框，表示他不是一个调用消息，不会引发其他对象的活动
		- 自身消息：若果对象的一个方法调用了自己的另外一个方法时，消息是由对象发送给自身。
		- 创建/销毁消息：创建消息用于使用new关键字创建另一个对象，而销毁消息用于调用对象的销毁方法将一个对象从内存中销毁

# 第十一章 设计概念
- 从需求模型到设计模型的转换
	- P132 11-1
- 关注点分离
	- 关注点分离是一个设计概念，它表明任何复杂问题如果被分解为可以独立解决或优化的若干块，该复杂问题便能够更容易地得到处理。关注点是一个特征或一个行为，被指定为软件需求模型的一部分。
- 模块化
	- 模块化是关注点分类最常见的表现。软件被划分为独立命名的，可处理的构件，有时被称为模块，把这些构建集成到一起可以满足问题的需求
- 信息隐蔽
	- 信息隐蔽原则建议模块因该具有的特征是每个模块对其他所有模块都隐蔽自己的设计决策。换句话说，模块应该被特别说明设计，使信息都包含在模块内，其他模块无需对着些信息进行访问。
- 功能独立
	- 功能独立的概念是关注点分离，模块化，抽象和信息隐蔽的产物。
	- 通过开发具有专一功能和避免与其他模块过多交互的模块可以实现功能独立
	- 软件设计时因该使每一个模块仅涉及需求的某个特定子集，并且当从程序机构的其他部分观察时，每个模块都只有一个简单的接口。

# 第十二章 体系结构设计
- 软件体系结构
	- 体系结构并非可运行的软件。确切的说，他是一种表达，使你能够：
		- 对设计在满足既定需求方面的有效性分析
		- 在设计变更相对容易的阶段，考虑体系结构可能的选择方案
		- 降低与软件构件相关的风险。
- 以数据为中心的体系结构
	- 数据存储位于这种体系结构的中心，其他构建会经常访问该数据存储，并对存储中的数据进行更新，增加，修改或删除
- 数据流体系结构
	- 当数据经过一系列计算构件和操作构建的变换形成输出数据时，可以应用这种体系结构。管道-过滤器模式拥有一组称为过滤器的构件，这些构建通过管道连接，管道将数据从一个构件传送到下一个构件。每个过滤器独立于其上游和下游的构件而工作，过滤器的设计要针对某种形式的数据输入，并且产生某种特定形式的数据输出。过滤器没有必要了解与之相邻的其他过滤器的工作。
- 面向对象体系结构：
	- 系统的构件封装了数据和必须用于控制该数据的操作，构建通过信息传递进行通信与合作。
- 层次体系结构设计
	- P158 12-4
	- 层次体系结构定义了一系列不同的层次，每个层次各自完成操作，这些操作 逐渐接近机器的指令集。
	- 在外层，构建完成建立用户界面的操作；在内层构建完成建立操作系统接口的操作；中间层提供各种使用工具服务和应用软件功能。

# 第十三章 构件级设计
- 什么是构件
	- 系统中模块化的，可部署的和可替换的部件，该部件封装了现实，并对外提供了一组接口
- 设计基于类的构件
	- 基本设计原则
		- 开闭原则：模块构件应该对外延具有开放性，对修改具有封闭性。设计者应该采用一种无需对构件自身内部做修改就可以进行扩展的方式来说明构件
		- liskov替换原则：子类可以替换他们的基类。该原则建议：将从基类导出得类传递给构建时，使用基类的构件应该仍能正确完成其功能
		- 依赖倒置原则：依赖与抽象，而非具体实现。
		- 接口分离原则：多个客户专用接口比一个通用接口要好
		- 发布复用等价性原则：复用的粒度就是发布的粒度
		- 共同封装原则：一同变更的类应该合在一起
		- 共同服用原则：不能一起复用的类不能被分到一组
- 构件级设计指导方针
	- 构件
		- 对那些已经被确定为体系模型的一部分构件应该建立命名约定，并对其作进一步的精细化处理，使其成为构建及模型的一部分
	- 接口
		- 接口提供关于通信和协作的重要信息
		- 但构件变得复杂时，在较正式的uml框和需箭头记号方法中使用接口的棒棒糖记号
		- 为了保俶一致，接口都放在构建框的左边
		- 即使其他的结构也都适用，也只表现出那些与构建相关的接口
	- 依赖与继承
		- 为了提高可读性，依赖关系自左到右，继承关系自底（继承类）向上（基类）
- 内聚性
	- 功能内聚
		- 主要通过操作来体现，当一个模块完成一组且只有一组操作并返回结果时，就称此模块时内聚的
	- 分层内聚
		- 由包，构件来实现，高层能够访问低层的服务，但底层不能够访问高层的服务
	- 通信内聚
		- 访问相同数据的所有操作被定义在一个类中，一般说来，这些类只着眼于数据的查询，访问和存储。
- 耦合性
	- 耦合是类之间彼此联系程度的一种定性度量。随着类（构件）之间的相互依赖越来越多，类之间的耦合程度亦会增加。在构建及设计中一个重要而目标就是尽可能保持低耦合。

# 第十四章 用户界面设计
- 黄金规则（详细见简答）
	- 把控制权交给用户
	- 减轻用户的记忆负担
	- 保持界面一致



# 第十七章 软件测试策略
- 软件测试的策略性方法
	- 测试模板
		- 为完成有效的测试，应该进行有效的，正式的技术评审。通过评审，许多错误可以在测试开始之前排除
		- 测试开始于构件层，谭厚向外延伸到整个基于计算机系统的集成中
		- 不同的测试技术适用于不同的软件工程方法和不同的时间点
		- 测试由软件开发人员和（对大型项目而言）独立的测试组执行
		- 测试和调试是不同的活动，但任何测试策略都必须包括调试 
	- 测试的进度必须是可测量的，并且应该让问题尽可能早的暴漏。
- 单元测试
	- 单元测试侧重于软件设计的最小单元的验证工作。利用构件级设计描述作为指南，测试重要的控制路径以发现模块的内的错误。测试的相对复杂度和这类测试发现的错误收到单元测试约束范围的限制。单元测试侧重于构件的内部处理逻辑和数据结构。这种类型的测试可以对多个构件并行执行
- 集成测试
	- 集成测试是构建软件体系结构的系统化技术，同时也是进行一些旨在发现与接口相关的错误的测试。其目标是利用已通过单元测试的构件建立设计中描述的程序结构
	- 自顶向下集成
		- 自顶向下集成测试是一种构建软件体系结构的增量方法。模块的集成顺序从主控模块开始，沿着控制层次逐步向下，以深度优先或广度优先的方式将从属于主控模块的模块集成到结构中去。
		- 测试的步骤可以分为以下五个步骤完成 （图17-5）
			- 主控模块用作测试驱动模块，用直接从属于主控模块的所有模块代替桩模块
			- 依靠所选择的集成方法（深度优先或者广度优先）每次用实际模块替换一个从属桩模块
			- 集成每个模块后都进行测试
			- 在完成每个测试集后，用实际模块替换另一个桩模块
			- 可以执行回归测试以确保没有引入新的错误
			- 回到第二部继续执行次过程
	- 自底向上集成测试
		- 自底向上集成测试，顾名思义，就是从原子模块（程序结构的最底层软件）开始进行构建和测试。由于构件是自底向上集成的，在处理时所需要的从属于给定层次的模块总时存在的，因此没有必要使用桩模块。
		- 步骤 图17-6
			- 连接底层构建以构成完成特定子功能的簇
			- 编写驱动模块（测试的控制程序）以协调测试用力的输入和输出 
			- 测试簇
			- 去掉驱动程序，沿着程序结构向上逐步连接簇 
		- 连接相应的构件形成簇1，簇2和簇3，利用驱动模块（图中的虚线模块）对每个簇进行测试。簇1和簇2中的构件从属模块Ma，去掉驱动模块D1和D2，将这两个簇直接与Ma相连。与之相类似，在簇3与Mb连接之前去掉驱动模块D3。最后将Ma和Mb与构件Mc连接在一起，以此类推

- 回归测试
	- 每当加入一个新模块作为集成测试的一部分时，软件发生变更，建立了新的数据流路径，可能出现新的I/O，还可能调用新的控制逻辑。这些变更所带来的副作用可能会使原来可以郑成功做的功能产生问题
	- 回归测试使重新执行已测试过的某些子集，以确保变更没有传播不期望的副作用。回归测试有助于保证变更不引入无意识行为或额外的错误
	- 回归测试套件包含以下三种测试用例
		- 能够测试软件所有功能的具有代表性的测试样本
		- 额外测试，侧重于可能会受变更影响的软件功能
		- 侧重于已发生变更的软件构建测试
-阿尔法测试和贝特测试
	- 阿尔法测试是由有代表性的最终用户在开发者的场所进行。软件在自然设置下使用，开发者站在用户的后面观看，并记录错误和使用问题。阿尔法测试在受控的环境下运行
	- 贝特测试在一个或多个最终用户场所进行。与阿尔法测试不同，开发者通常不在场，因此贝特测试是在不为开发者控制的环境下“现场”应用软件。最终用户记录测试过程中遇见的所有问题（现实存在的或想象的）并定期报告给开发者。接到贝特测试的问题报告之后，开发人员对软件进行修改，然后准备向最终用户发布软件产品
- 安全测试
	- 安全测试验证建立在系统内的保护机制是否能够实际保护系统不受非法入侵。
- 压力测试
	- 见简答
- 性能测试
	- 性能测试用来测试软件在集成环境中的运行性能。在测试过程的任何步骤都可以进行性能测试。只有当整个系统的所有成分完全集成之后，才能确定系统的真实性能。

# 第十八章 测试传统的应用软件
- 白盒测试
	- 白盒测试有时也称为玻璃盒测试或结构化测试，是一种测试用例设计方法，他利用作为构件级设计的一部分所描述的控制结构来生成测试用例。利用白盒测试方法导出的测试用例可以：
		- 保证一个模块中的所有独立路径至少被执行一次；
		- 对所有的逻辑判定均需测试取真和取假两个方面；
		- 在上下边界及可操作的范围内执行所有循环数据结构以确保其有效性
- 基本路径测试
	- 基本路经测试方法允许测试用例设计者计算出过程设计的逻辑复杂性测量，并以这种测量为指导来定义执行路径的基本集。执行给基本集导出的测试用例，保证程序中的每一条语句至少执行一次
	- 流图表示
		- 流图利用P272 18-1所示的表示描述逻辑控制流。每种结构化构造都有相应的符号
		- 圆称为流图结点，表示一个或多个过程语句。
		- 箭头称为边或连接，表示控制流
	- 独立程序路径
		- P273 计算
		- 环路复杂性
			- 流图中域的数量与环境复杂性相对应
			- 对于流图G，换复杂性V（G）定义如下
				- V(G) = E - N +2
				- E为流图的边数，N为节点数
			- 对于流图G，环复杂性V(G)也可以定义如下
				- V(G) = P + 1
				- P为包含在流图G中的判定节点数
- 控制结构测试
	- 条件测试通过检查程序模块中包含的逻辑条件进行测试用例设计。
	- 数据流测试根据程序中变量的定义和使用位置来选择程序的测试路径。
	- 循环测试是一种白盒测试技术，完全侧重于循环构建的有效性。可以定义四种不同的循环 P276 18-6
		- 简单循环
		- 串接循环
		- 嵌套循环
		- 非结构化循环

- 黑盒测试
	- 黑盒测试也称为行为测试或功能测试，侧重于软件的功能需求。黑盒测试使软件工程师能设计处可以测试程序所有功能需求的输入条件集。黑盒测试并不是白盒测试的替代品，而是作为发现其他类型错误的辅助方法。
	- 与白盒测试不同，黑盒测试倾向于应用在测试后期阶段

	- 等价类划分
		- 等价类划分是一种黑盒测试方法，他将程序的输入划分为若干个数据类，从中生成测试用例。理想的测试用例可以单独发现一类错误，否则在观察到一般的错误之前需要运行许多测试用例
		- 可以根据下述原则定义等价类
			- 若输入条件指定一个范围，则可以定义一个有效等价类和两个无效等价类
			- 若输入条件需要特定的值，则可以定义一个有效的等价类和两个无效的等价类
			- 若输入条件制定集合的某个元素，则可以定义一个有效的等价类和一个无效的等价类
			- 若输入条件为布尔值，则可以定义一个有效的等价类和一个无效的等价类
	- 边界值分析
		- 边界值分析是一种测试用例设计技术，是对等价划分的补充,BVA不是选择等价类的任何元素，而是在等价类边缘上选择测试用例。BVA不仅仅侧重于输入条件，他页能从输出域中导出测试用例
		- 原则
			- 若输入条件以a和b为边界的范围，则测试用例应该包括a和b，略大于和略小于a和b
			- 若输入的条件指定为一组值，则测试用例应当执行其中的最大最小值，和略大略小值
			- 若知道原则1和2也适用于输出条件，应该设计测试用例创建输出报告，输出报告可生成所允许的最大值和最小数部的表项
			- 若内部程序数据结构由预定义的边界值，自一定要设计测试用例，在其边界处测试数据结构。
	- 基于模型的测试
		- 基于模型的测试是一种黑盒测试技术，他使用需求模型中的信息作为生成测试用例的基础。在很多情况下，基于模型的测试技术使用uml状态图作为测试用例设计的基础
		- 需要以下步骤
			- 分析软件的已有行为模型或创建一个行为模型
			- 遍历行为模型，并标明促使软件在状态之间进行转换的输入
			- 评估行为模型，并标注当软件在状态之间转换时所期望的输出
			- 运行测试用例
			- 比较实际结果和期望结果，并根据需要进行调整

# 第十九章 测试面向对象的应用
- 面向对象中的集成测试
	- 由于面向对象软件不具有层次控制结构，因此传统的自顶向下和自底向上策略是没有意义的。另外由于组成类的构件之间的直接和非直接交互，因此每次将一个操作集成到类中是不可能的
	- 第一种集成策略是基于线程的测试，将相应系统的一个输入或一个时间所需要的一组类集成到一起。每一个线程单独集成和测试，并应用回归测试确保不产生副作用
	- 第二种集成策略是基于使用的测试，通过测试那些很少使用的服务器类（称为独立类）的类开始系统的构建，测试完成后，测试使用独立类的下一层类（称为依赖类）。直到整个系统构建完成。
	- 簇测试是面向对象软件集成测试中的一个步骤。通过设计试图发现协作错误的测试用例，对一簇协作类进行测试（通过检查CRC和对象-关系模型来确定）

# 第二十一章 软件配置管理
- 基线
	- IEEE标准定义:
	- 已经通过正是评审和批准的规格说明或产品，它可以作为进一步开发的基础，并且只有通过正式的变更控制规程才能修改它
	- 基线化的SCI和项目数据库 P309 21-1
- SCM中心存储库
	- SCM中心管理库是一组机制和数据结构，它使软件团队可以有效地管理变更。通过保证数据完整性，信息共享和数据集成，它具有数据库管理系统的一般功能，此外，SCM中心存储库还未软件工具的集成提供了中枢，他是软件过程流的核心。他能够使软件工程工作产品强制实施统一的结构和格式
	- 一个健壮的中心存储库能够提供两种不同类型的服务
		- 期望从任何一个复杂的数据库管理系统得到相同的服务类型
		- 特定与软件工程环境的服务类型
	- 作为软件工程团队中心的存储库，应该：
		- 集成或直接使用过程管理功能
		- 支持在中心存储库中管理SCB功能的特定规则和维护数据
		- 提供与其他软件工程工具的机构
		- 能够存储各种数据对象
	- SCM特征
		- 中心数据库必须支持下列特征的工具集
			- 版本控制
			- 依赖性跟踪和变更管理
			- 需求跟踪
			- 配置管理
			- 审核跟踪

# 第二十二章 软件管理项目
- 管理涉及的范围
	- 4p。即人员，产品，过程和项目
- W5HH原则
	- 描述项目的目标，里程碑，进度，责任，管理和技术方法以及需要的资源
	- why ，what ，when ，who ，where ，how ，how much


# 第二十三章 过程度量与项目度量
- 测量质量
	- 正确性
		- 正确行是软件完成所要求的功能的程度。缺陷是指在程序发布后经过了全面的使用，由程序用户报告的问题
	- 可维护性
		- 可维护性是指遇到错误时程序能够被修改的容易程度，环境发生变化时程序能够适应的容易程度，以及用户希望变更需求时程序能够被增强的容易程度
		- 还没有直接测量的方法，可以间接用平均变更时间测量
	- 完整性
		- 这个属性测量的是一个系统对安全性攻击（包括偶然的和蓄意的）的抵抗能力。
		- 为了测量完整性，必须定义另外两个属性：安全性和危险性
		- 危险性是指一个特定类型的攻击在给定的时间内发生的概率。
		- 安全性是指一个特定类型的攻击被击退的概率
		- 完整性定义为
			- 求和（1 - （危险性 * （1 - 安全性）））
	- 可用性
		- 可用性力图对使用的容易程度进行量化
- 缺陷排除效率DRE
	- 缺陷排除效率是在项目级和过程级都有意义的质量度量。质量保证及质量控制活动贯穿于所有过程框架活动中，DRE本质上就是对质量保证及质量控制动作中滤除缺陷的能力
	- DRE = E/(E+D)
	- 其中E是软件交付给最终用户之前发现的错误数，D是软件交付之后发现的缺陷数
	
	- 在项目内部也可以使用DRE来评估一个团队在错误传递到下一个框架活动或软件工程任务之前发现错误的能力
	- DREi = Ei/（Ei + Ei+1）
	- 其中Ei是软件工程动作i中发现的错误数，Ei+1是指在软件工程动作i+1中发现的而在i中没有发现的错误

# 第二十四章 软件项目估算
- 如果采用直接的方法，规模可以用代码行LOC估算。如果采用间接的方法，规模可以用功能点FP估算
- 基于问题的估算
	- 通过乐观值Sopt，可能指值Sm，悲观值Spess估算的加权平均值来计算估算变量规模S的期望值
	- S = （Sopt + 4*Sm + Spess）/6  4为加权因子
- 基于LOC的估算
	- 根据每一个功能的乐观值，可能值，和悲观值 求出LOC估算值
	- 对所有的功能LOC估算值求和
- 基于FP的估算
	- 总计计算方法同上 只是加权因子不固定为4
	- FPestimated = 总计 * （0.65 + 0.01求和（Fi））